diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
index c3893e9..25d6f25 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -29,34 +29,34 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @param elemento el elemento del vértice.
          */
         public Vertice(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
 
         /**
          * Nos dice si el vértice tiene un padre.
-         * @return <code>true</code> si el vértice tiene padre,
-         *         <code>false</code> en otro caso.
+         * @return <tt>true</tt> si el vértice tiene padre,
+         *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayPadre() {
-            // Aquí va su código.
+            return padre != null;
         }
 
         /**
          * Nos dice si el vértice tiene un izquierdo.
-         * @return <code>true</code> si el vértice tiene izquierdo,
-         *         <code>false</code> en otro caso.
+         * @return <tt>true</tt> si el vértice tiene izquierdo,
+         *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayIzquierdo() {
-            // Aquí va su código.
+            return izquierdo != null;
         }
 
         /**
          * Nos dice si el vértice tiene un derecho.
-         * @return <code>true</code> si el vértice tiene derecho,
-         *         <code>false</code> en otro caso.
+         * @return <tt>true</tt> si el vértice tiene derecho,
+         *         <tt>false</tt> en otro caso.
          */
         @Override public boolean hayDerecho() {
-            // Aquí va su código.
+            return derecho != null;
         }
 
         /**
@@ -65,7 +65,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
         @Override public VerticeArbolBinario<T> padre() {
-            // Aquí va su código.
+            if (padre == null)
+                throw new NoSuchElementException();
+            return padre;
         }
 
         /**
@@ -74,7 +76,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
         @Override public VerticeArbolBinario<T> izquierdo() {
-            // Aquí va su código.
+            if (izquierdo == null)
+                throw new NoSuchElementException();
+            return izquierdo;
         }
 
         /**
@@ -83,7 +87,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
         @Override public VerticeArbolBinario<T> derecho() {
-            // Aquí va su código.
+            if (derecho == null)
+                throw new NoSuchElementException();
+            return derecho;
         }
 
         /**
@@ -91,7 +97,14 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+            if (izquierdo == null) {
+                if (derecho == null)
+                    return 0;
+                return 1 + derecho.altura();
+            }
+            else if (derecho == null)
+                return 1 + izquierdo.altura();
+            return 1 + Math.max(izquierdo.altura(), derecho.altura());
         }
 
         /**
@@ -99,7 +112,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la profundidad del vértice.
          */
         @Override public int profundidad() {
-            // Aquí va su código.
+            if (padre == null)
+                return 0;
+            return 1 + padre.profundidad();
         }
 
         /**
@@ -107,7 +122,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el elemento al que apunta el vértice.
          */
         @Override public T get() {
-            // Aquí va su código.
+            return elemento;
         }
 
         /**
@@ -124,7 +139,18 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
-            // Aquí va su código.
+            return equals(this, vertice);
+        }
+
+        private boolean equals(Vertice u, Vertice v) {
+            if (u == null && v == null)
+                return true;
+            else if (u != null && v == null || u == null && v != null)
+                return false;
+            else if (u.elemento.equals(v.elemento))
+                return equals(u.izquierdo, v.izquierdo)?
+                           equals(u.derecho, v.derecho):false;
+            return false;
         }
 
         /**
@@ -132,7 +158,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return una representación en cadena del vértice.
          */
         public String toString() {
-            // Aquí va su código.
+            return elemento.toString();
         }
     }
 
@@ -153,7 +179,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *        binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-        // Aquí va su código.
+        for (T elemento : coleccion)
+            agrega(elemento);
     }
 
     /**
@@ -166,7 +193,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return un nuevo vértice con el elemento recibido dentro del mismo.
      */
     protected Vertice nuevoVertice(T elemento) {
-        // Aquí va su código.
+        return new Vertice(elemento);
     }
 
     /**
@@ -175,7 +202,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return la altura del árbol.
      */
     public int altura() {
-        // Aquí va su código.
+        if (raiz == null)
+            return -1;
+        return raiz.altura();
     }
 
     /**
@@ -183,7 +212,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el número de elementos en el árbol.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return elementos;
     }
 
     /**
@@ -193,18 +222,29 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        return busca(elemento) != null;
     }
 
+
     /**
      * Busca el vértice de un elemento en el árbol. Si no lo encuentra regresa
-     * <code>null</code>.
+     * <tt>null</tt>.
      * @param elemento el elemento para buscar el vértice.
      * @return un vértice que contiene el elemento buscado si lo encuentra;
-     *         <code>null</code> en otro caso.
+     *         <tt>null</tt> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca(raiz, elemento);
+    }
+
+    private Vertice busca(Vertice v, T elemento) {
+        if (v == null)
+            return null;
+        else if (v.get().equals(elemento))
+            return v;
+        return busca(v.izquierdo, elemento) != null?
+               busca(v.izquierdo, elemento):busca(v.derecho, elemento);
+
     }
 
     /**
@@ -213,7 +253,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el árbol es vacío.
      */
     public VerticeArbolBinario<T> raiz() {
-        // Aquí va su código.
+        if (raiz == null)
+            throw new NoSuchElementException();
+        return raiz;
     }
 
     /**
@@ -222,14 +264,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return raiz == null;
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        raiz = null;
+        elementos = 0;
     }
 
     /**
@@ -243,7 +286,12 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             return false;
         @SuppressWarnings("unchecked")
             ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
-        // Aquí va su código.
+        if (raiz == null && arbol.raiz == null)
+            return true;
+        else if (raiz != null && arbol.raiz == null ||
+                 raiz == null && arbol.raiz != null)
+            return false;
+        return raiz.equals(arbol.raiz);
     }
 
     /**
@@ -251,7 +299,48 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return una representación en cadena del árbol.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        if (raiz == null)
+            return "";
+        int a = altura() + 1;
+        int[] arreglo = new int[a];
+        for (int i = 0; i < a; i++)
+            arreglo[i] = 0;
+        return toString(raiz, 0, arreglo);
+    }
+
+    private String dibujaEspacios(int nivel, int[] arreglo) {
+        String r = "";
+        for (int i = 0; i < nivel; i++)
+            if (arreglo[i] == 1)
+                r += "│  ";
+            else
+                r += "   ";
+        return r;
+    }
+
+    private String toString(Vertice v, int nivel, int[] arreglo) {
+        String s = v + "\n";
+        arreglo[nivel] = 1;
+        if (v.izquierdo != null && v.derecho != null) {
+            s += dibujaEspacios(nivel, arreglo);
+            s += "├─›";
+            s += toString(v.izquierdo, nivel + 1, arreglo);
+            s += dibujaEspacios(nivel, arreglo);
+            s += "└─»";
+            arreglo[nivel] = 0;
+            s += toString(v.derecho, nivel + 1, arreglo);
+        } else if (v.izquierdo != null) {
+            s += dibujaEspacios(nivel, arreglo);
+            s += "└─›";
+            arreglo[nivel] = 0;
+            s += toString(v.izquierdo, nivel + 1, arreglo);
+        } else if (v.derecho != null) {
+            s += dibujaEspacios(nivel, arreglo);
+            s += "└─»";
+            arreglo[nivel] = 0;
+            s += toString(v.derecho, nivel + 1, arreglo);
+        }
+        return s;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index 97a2ea0..e09c6fd 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -18,17 +18,24 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
 
         /* Inicializa al iterador. */
         public Iterador() {
-            // Aquí va su código.
+            cola = new Cola<Vertice>();
+            if (raiz != null)
+                cola.mete(raiz);
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !cola.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
-            // Aquí va su código.
+            Vertice v = cola.saca();
+            if (v.hayIzquierdo())
+                cola.mete(v.izquierdo);
+            if (v.hayDerecho())
+                cola.mete(v.derecho);
+            return v.get();
         }
     }
 
@@ -56,7 +63,29 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Vertice v = nuevoVertice(elemento);
+        elementos++;
+        if (esVacia())
+            raiz = v;
+        else {
+            Cola<Vertice> cola = new Cola<Vertice>();
+            cola.mete(raiz);
+            while (!cola.esVacia()) {
+                Vertice t = cola.saca();
+                if (!t.hayIzquierdo() || !t.hayDerecho()) {
+                    v.padre = t;
+                    if (!t.hayIzquierdo())
+                        t.izquierdo = v;
+                    else if (!t.hayDerecho())
+                        t.derecho = v;
+                    break;
+                }
+                cola.mete(t.izquierdo);
+                cola.mete(t.derecho);
+            }
+        }
     }
 
     /**
@@ -66,7 +95,37 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        Vertice e = vertice(busca(elemento));
+        if (e == null)
+            return;
+        else {
+            elementos--;
+            if (elementos == 0)
+                raiz = null;
+            else {
+                Vertice u = bfsUltimo();
+                e.elemento = u.elemento;
+                if (u.padre.izquierdo == u)
+                    u.padre.izquierdo = null;
+                u.padre.derecho = null;
+                u.elemento = null;
+            }
+        }
+    }
+
+    private Vertice bfsUltimo() {
+        Cola<Vertice> cola = new Cola<Vertice>();
+        cola.mete(raiz);
+        Vertice ultimo = null;
+        while (!cola.esVacia()) {
+            Vertice v = cola.saca();
+            if (v.hayIzquierdo())
+                cola.mete(v.izquierdo);
+            if (v.hayDerecho())
+                cola.mete(v.derecho);
+            ultimo = v;
+        }
+        return ultimo;
     }
 
     /**
@@ -75,7 +134,10 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @return la altura del árbol.
      */
     @Override public int altura() {
-        // Aquí va su código.
+        if (raiz == null)
+            return -1;
+        int r = (int)Math.floor(Math.log(elementos) / Math.log(2));
+        return r;
     }
 
     /**
@@ -84,7 +146,20 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        if (esVacia())
+            return;
+        else {
+            Cola<Vertice> cola = new Cola<Vertice>();
+            cola.mete(raiz);
+            while (!cola.esVacia()) {
+                Vertice v = cola.saca();
+                accion.actua(v);
+                if (v.hayIzquierdo())
+                    cola.mete(v.izquierdo);
+                if (v.hayDerecho())
+                    cola.mete(v.derecho);
+            }
+        }
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index ea913b1..ba37f2b 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -25,17 +25,30 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
 
         /* Inicializa al iterador. */
         public Iterador() {
-            // Aquí va su código.
+            pila = new Pila<Vertice>();
+            Vertice v = raiz;
+            while (v != null) {
+                pila.mete(v);
+                v = v.izquierdo;
+            }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !pila.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
         @Override public T next() {
-            // Aquí va su código.
+            Vertice v = pila.saca();
+            if (v.hayDerecho()) {
+                Vertice u = v.derecho;
+                while (u != null) {
+                    pila.mete(u);
+                    u = u.izquierdo;
+                }
+            }
+            return v.get();
         }
     }
 
@@ -69,7 +82,35 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Vertice v = nuevoVertice(elemento);
+        elementos++;
+        if (esVacia()) {
+            raiz = ultimoAgregado = v;
+            return;
+        }
+        comparaAgrega(raiz, v);
+    }
+
+    private void comparaAgrega(Vertice u, Vertice v) {
+        if (v.elemento.compareTo(u.elemento) <= 0) {
+            if (!u.hayIzquierdo()) {
+                u.izquierdo    = v;
+                v.padre        = u;
+                ultimoAgregado = v;
+                return;
+            }
+            comparaAgrega(u.izquierdo, v);
+        } else {
+            if (!u.hayDerecho()) {
+                u.derecho      = v;
+                v.padre        = u;
+                ultimoAgregado = v;
+                return;
+            }
+            comparaAgrega(u.derecho, v);
+        }
     }
 
     /**
@@ -79,7 +120,18 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        Vertice e = vertice(busca(elemento));
+        if (e == null)
+            return;
+        if (!e.hayIzquierdo() && !e.hayDerecho())
+            eliminaVertice(e);
+        else if (e.hayIzquierdo() && !e.hayDerecho())
+            eliminaVertice(e);
+        else if (!e.hayIzquierdo() && e.hayDerecho())
+            eliminaVertice(e);
+        else if (e.hayIzquierdo() && e.hayDerecho())
+            eliminaVertice(intercambiaEliminable(e));
+        return;
     }
 
     /**
@@ -92,7 +144,16 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         de <code>null</code>.
      */
     protected Vertice intercambiaEliminable(Vertice vertice) {
-        // Aquí va su código.
+        Vertice v = maximoEnSubarbol(vertice.izquierdo);
+        vertice.elemento = v.elemento;
+        v.elemento = vertice.elemento;
+        return v;
+    }
+
+    private Vertice maximoEnSubarbol(Vertice v) {
+        if (!v.hayDerecho())
+            return v;
+        return maximoEnSubarbol(v.derecho);
     }
 
     /**
@@ -102,18 +163,71 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *                distinto de <code>null</code>.
      */
     protected void eliminaVertice(Vertice vertice) {
-        // Aquí va su código.
+        if (!vertice.hayIzquierdo() && !vertice.hayDerecho()) {
+            if (vertice == raiz) {
+                raiz = null;
+                elementos--;
+                return;
+            }
+            elementos--;
+            if (vertice.padre.izquierdo == vertice) {
+                vertice.padre.izquierdo = null;
+                vertice = null;
+            } else {
+                vertice.padre.derecho = null;
+                vertice = null;
+            }
+        } else if (vertice.hayIzquierdo() && !vertice.hayDerecho()) {
+            if (vertice == raiz) {
+                raiz = vertice.izquierdo;
+                vertice.izquierdo.padre = null;
+                elementos--;
+                return;
+            }
+            elementos--;
+            if (vertice.padre.izquierdo == vertice) {
+                vertice.padre.izquierdo = vertice.izquierdo;
+                vertice.izquierdo.padre = vertice.padre;
+            } else {
+                vertice.padre.derecho = vertice.izquierdo;
+                vertice.izquierdo.padre = vertice.padre;
+            }
+        } else if (!vertice.hayIzquierdo() && vertice.hayDerecho()) {
+            if (vertice == raiz) {
+                raiz = vertice.derecho;
+                vertice.derecho.padre = null;
+                elementos--;
+                return;
+            }
+            elementos--;
+            if (vertice.padre.izquierdo == vertice) {
+                vertice.padre.izquierdo = vertice.derecho;
+                vertice.derecho.padre = vertice.padre;
+            } else {
+                vertice.padre.derecho = vertice.derecho;
+                vertice.derecho.padre = vertice.padre;
+            }
+        }
     }
 
     /**
      * Busca un elemento en el árbol recorriéndolo in-order. Si lo encuentra,
-     * regresa el vértice que lo contiene; si no, regresa <code>null</code>.
+     * regresa el vértice que lo contiene; si no, regresa <tt>null</tt>.
      * @param elemento el elemento a buscar.
      * @return un vértice que contiene al elemento buscado si lo
-     *         encuentra; <code>null</code> en otro caso.
+     *         encuentra; <tt>null</tt> en otro caso.
      */
     @Override public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca(raiz, elemento);
+    }
+
+    private Vertice busca(Vertice v, T elemento) {
+        if (v == null)
+            return null;
+        else if (elemento.equals(v.elemento))
+            return v;
+        return elemento.compareTo(v.elemento) <= 0?
+               busca(v.izquierdo, elemento):busca(v.derecho, elemento);
     }
 
     /**
@@ -128,7 +242,7 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         elemento al árbol.
      */
     public VerticeArbolBinario<T> getUltimoVerticeAgregado() {
-        // Aquí va su código.
+        return ultimoAgregado;
     }
 
     /**
@@ -137,7 +251,23 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (vertice == null || !vertice(vertice).hayIzquierdo())
+            return;
+        Vertice q = vertice(vertice);
+        Vertice p = q.izquierdo;
+        Vertice pDerecho = p.derecho;
+        p.derecho = q;
+        p.padre = q.padre;
+        q.izquierdo = pDerecho;
+        if (q.izquierdo != null)
+            q.izquierdo.padre = q;
+        if (p.padre == null)
+            raiz = p;
+        else if (q.padre.izquierdo == q)
+            q.padre.izquierdo = p;
+        else
+            q.padre.derecho = p;
+        q.padre = p;
     }
 
     /**
@@ -146,7 +276,23 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (vertice == null || !vertice(vertice).hayDerecho())
+            return;
+        Vertice p = vertice(vertice);
+        Vertice q = p.derecho;
+        Vertice qIzquierdo = q.izquierdo;
+        q.izquierdo = p;
+        q.padre = p.padre;
+        p.derecho = qIzquierdo;
+        if (p.derecho != null)
+            p.derecho.padre = p;
+        if (q.padre == null)
+            raiz = q;
+        else if (p.padre.izquierdo == p)
+            p.padre.izquierdo = q;
+        else
+            p.padre.derecho = q;
+        p.padre = q;
     }
 
     /**
@@ -155,7 +301,15 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPreOrder(accion, raiz);
+    }
+
+    private void dfsPreOrder(AccionVerticeArbolBinario<T> accion, Vertice v) {
+        if (v == null)
+            return;
+        accion.actua(v);
+        dfsPreOrder(accion, v.izquierdo);
+        dfsPreOrder(accion, v.derecho);
     }
 
     /**
@@ -164,7 +318,15 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsInOrder(accion, raiz);
+    }
+
+    private void dfsInOrder(AccionVerticeArbolBinario<T> accion, Vertice v) {
+        if (v == null)
+            return;
+        dfsInOrder(accion, v.izquierdo);
+        accion.actua(v);
+        dfsInOrder(accion, v.derecho);
     }
 
     /**
@@ -173,7 +335,15 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPostOrder(accion, raiz);
+    }
+
+    private void dfsPostOrder(AccionVerticeArbolBinario<T> accion, Vertice v) {
+        if (v == null)
+            return;
+        dfsPostOrder(accion, v.izquierdo);
+        dfsPostOrder(accion, v.derecho);
+        accion.actua(v);
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Arreglos.java b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
index 641317c..8d8729a 100644
--- a/src/main/java/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
@@ -18,6 +18,7 @@ public class Arreglos {
      */
     public static <T> void
     quickSort(T[] arreglo, Comparator<T> comparador) {
+      quickSort(arreglo, comparador, 0, arreglo.length -1);
         // Aquí va su código.
     }
 
@@ -30,6 +31,27 @@ public class Arreglos {
     quickSort(T[] arreglo) {
         quickSort(arreglo, (a, b) -> a.compareTo(b));
     }
+    /*Método auxiliar para quickSort. */
+    private static <T> void
+    quickSort(T[] arreglo, Comparator<T> comparador, int inicio, int fin) {
+        if (fin <= inicio)
+            return;
+        int i = inicio + 1;
+        int j = fin;
+        while (i < j)
+            if (comparador.compare(arreglo[i], arreglo[inicio]) > 0 &&
+                comparador.compare(arreglo[j], arreglo[inicio]) <= 0)
+                intercambia(arreglo, i++, j--);
+            else if (comparador.compare(arreglo[i], arreglo[inicio]) <= 0)
+                i++;
+            else
+                j--;
+        if (comparador.compare(arreglo[i], arreglo[inicio]) > 0)
+            i--;
+        intercambia(arreglo, inicio, i);
+        quickSort(arreglo, comparador, inicio, i - 1);
+        quickSort(arreglo, comparador, i + 1, fin);
+    }
 
     /**
      * Ordena el arreglo recibido usando SelectionSort.
@@ -39,8 +61,23 @@ public class Arreglos {
      */
     public static <T> void
     selectionSort(T[] arreglo, Comparator<T> comparador) {
+      for (int i = 0; i < arreglo.length; i++) {
+        int m = i;
+        for (int j = i +1; j < arreglo.length; j++)
+           if (comparador.compare(arreglo[m], arreglo[j]) > 0)
+              m = j;
+            intercambia(arreglo, i, m);
+      }
         // Aquí va su código.
     }
+    /* Método auxiliar para intercambiar elementos dentro de un arreglo. */
+private static <T> void intercambia(T[] arreglo, int a, int b) {
+    if (a == b)
+        return;
+    T auxiliar = arreglo[a];
+    arreglo[a] = arreglo[b];
+    arreglo[b] = auxiliar;
+}
 
     /**
      * Ordena el arreglo recibido usando SelectionSort.
@@ -63,6 +100,19 @@ public class Arreglos {
      */
     public static <T> int
     busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
+     quickSort(arreglo, comparador);
+    int inicio = 0;
+    int fin = arreglo.length -1;
+    while (inicio <= fin) {
+        int r = inicio + (fin - inicio)/ 2;
+        if (comparador.compare(arreglo[r], elemento) == 0)
+           return r;
+        else if (comparador.compare(arreglo[r], elemento) < 0)
+           inicio = r + 1;
+        else
+            fin = r - 1;
+    }
+    return -1;
         // Aquí va su código.
     }
 
diff --git a/src/main/java/mx/unam/ciencias/edd/Cola.java b/src/main/java/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..988d21b 100644
--- a/src/main/java/mx/unam/ciencias/edd/Cola.java
+++ b/src/main/java/mx/unam/ciencias/edd/Cola.java
@@ -10,6 +10,15 @@ public class Cola<T> extends MeteSaca<T> {
      * @return una representación en cadena de la cola.
      */
     @Override public String toString() {
+      String r = "";
+        if (cabeza == null)
+            return r;
+        Nodo n = cabeza;
+        while (n != null) {
+            r += n.elemento.toString() + ",";
+            n = n.siguiente;
+        }
+        return r;
         // Aquí va su código.
     }
 
@@ -20,6 +29,15 @@ public class Cola<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+      Nodo n = new Nodo (elemento);
+      if (cabeza == null)
+         cabeza = rabo = n;
+      else {
+        rabo.siguiente = n;
+        rabo = n;
+      }
         // Aquí va su código.
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Lista.java b/src/main/java/mx/unam/ciencias/edd/Lista.java
index f56592a..a35fd91 100644
--- a/src/main/java/mx/unam/ciencias/edd/Lista.java
+++ b/src/main/java/mx/unam/ciencias/edd/Lista.java
@@ -28,6 +28,7 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nodo con un elemento. */
         public Nodo(T elemento) {
+          this.elemento = elemento;
             // Aquí va su código.
         }
     }
@@ -41,36 +42,54 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador. */
         public Iterador() {
+          this.siguiente = cabeza;
+          this.anterior = null;
             // Aquí va su código.
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
+          return this.siguiente != null;
             // Aquí va su código.
         }
 
         /* Nos da el elemento siguiente. */
         @Override public T next() {
+          if (this.siguiente == null)
+           throw new NoSuchElementException();
+          this.anterior = this.siguiente;
+          this.siguiente = this.siguiente.siguiente;
+           return anterior.elemento;
             // Aquí va su código.
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
+          return this.anterior != null;
             // Aquí va su código.
         }
 
         /* Nos da el elemento anterior. */
         @Override public T previous() {
+          if (this.anterior == null)
+           throw new NoSuchElementException();
+          this.siguiente = this.anterior;
+          this.anterior = this.anterior.anterior;
+           return siguiente.elemento;
             // Aquí va su código.
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
+          siguiente = cabeza;
+          anterior = null;
             // Aquí va su código.
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
+          anterior = rabo;
+          siguiente = null;
             // Aquí va su código.
         }
     }
@@ -88,6 +107,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
+      return longitud;
         // Aquí va su código.
     }
 
@@ -97,6 +117,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return el número elementos en la lista.
      */
     @Override public int getElementos() {
+      return longitud;
         // Aquí va su código.
     }
 
@@ -106,6 +127,7 @@ public class Lista<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
+      return cabeza == null;
         // Aquí va su código.
     }
 
@@ -118,6 +140,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+       Nodo n = new Nodo (elemento);
+       longitud ++;
+       if (esVacia())
+          cabeza = rabo = n;
+        else {
+          rabo.siguiente = n;
+          n.anterior     = rabo;
+          rabo           = n;
+        }
         // Aquí va su código.
     }
 
@@ -129,6 +162,7 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
+      agrega(elemento);
         // Aquí va su código.
     }
 
@@ -140,6 +174,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaInicio(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+       Nodo n = new Nodo (elemento);
+       longitud ++;
+       if (esVacia())
+          cabeza = rabo = n;
+        else {
+          cabeza.anterior = n;
+          n.siguiente     = cabeza;
+          cabeza            = n;
+        }
         // Aquí va su código.
     }
 
@@ -159,6 +204,23 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void inserta(int i, T elemento) {
+      if (elemento == null)
+          throw new IllegalArgumentException();
+      else if (i <= 0)
+          agregaInicio(elemento);
+      else if (i >= longitud)
+          agregaFinal(elemento);
+      else {
+          Nodo n0 = cabeza;
+          Nodo n = new Nodo(elemento);
+          longitud++;
+          for (int c = 0; c < i; c++)
+              n0 = n0.siguiente;
+          n.anterior = n0.anterior;
+          n.siguiente = n0;
+          n.siguiente.anterior = n;
+          n.anterior.siguiente = n;
+      }
         // Aquí va su código.
     }
 
@@ -168,8 +230,26 @@ public class Lista<T> implements Coleccion<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
+      Nodo d = buscaNodo(cabeza, elemento);
+       if (d == null)
+           return;
+       else if (d.equals(cabeza))
+           eliminaPrimero();
+       else if (d.equals(rabo))
+           eliminaUltimo();
+       else {
+           d.anterior.siguiente = d.siguiente;
+           d.siguiente.anterior = d.anterior;
+           longitud--;
+       }
         // Aquí va su código.
     }
+    /*Método auxiliar para buscar un nodo en la lista. */
+    private Nodo buscaNodo(Nodo n, T elemento) {
+      if (n == null)
+         return null;
+      return n.elemento.equals(elemento)?n:buscaNodo(n.siguiente, elemento);
+    }
 
     /**
      * Elimina el primer elemento de la lista y lo regresa.
@@ -177,6 +257,17 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaPrimero() {
+      if (esVacia())
+          throw new NoSuchElementException();
+      T elemento = cabeza.elemento;
+      longitud--;
+      if (cabeza == rabo)
+          cabeza = rabo = null;
+       else {
+          cabeza = cabeza.siguiente;
+          cabeza.anterior = null;
+      }
+      return elemento;
         // Aquí va su código.
     }
 
@@ -186,6 +277,17 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaUltimo() {
+      if (esVacia())
+          throw new NoSuchElementException();
+      T elemento = rabo.elemento;
+      longitud--;
+      if (cabeza == rabo)
+          cabeza = rabo = null;
+       else {
+          rabo = rabo.anterior;
+          rabo.siguiente = null;
+      }
+      return elemento;
         // Aquí va su código.
     }
 
@@ -196,6 +298,7 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
+      return (buscaNodo(cabeza, elemento) != null)?true:false;
         // Aquí va su código.
     }
 
@@ -204,6 +307,13 @@ public class Lista<T> implements Coleccion<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
+      Lista<T> r = new Lista<T>();
+      Nodo n = cabeza;
+      while (n != null) {
+         r.agregaInicio(n.elemento);
+         n = n.siguiente;
+      }
+      return r;
         // Aquí va su código.
     }
 
@@ -213,6 +323,13 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copiad de la lista.
      */
     public Lista<T> copia() {
+      Lista<T> r = new Lista<T>();
+      Nodo n = cabeza;
+      while (n != null) {
+         r.agregaFinal(n.elemento);
+         n = n.siguiente;
+      }
+      return r;
         // Aquí va su código.
     }
 
@@ -220,6 +337,8 @@ public class Lista<T> implements Coleccion<T> {
      * Limpia la lista de elementos, dejándola vacía.
      */
     @Override public void limpia() {
+      cabeza = rabo = null;
+      longitud = 0;
         // Aquí va su código.
     }
 
@@ -229,6 +348,9 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getPrimero() {
+      if (esVacia())
+       throw new NoSuchElementException();
+      return cabeza.elemento;
         // Aquí va su código.
     }
 
@@ -238,6 +360,9 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getUltimo() {
+      if (esVacia())
+       throw new NoSuchElementException();
+      return rabo.elemento;
         // Aquí va su código.
     }
 
@@ -249,6 +374,12 @@ public class Lista<T> implements Coleccion<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
+      if (i < 0 || i >= longitud)
+       throw new ExcepcionIndiceInvalido();
+      Nodo n = cabeza;
+      while (i-- > 0)
+          n = n.siguiente;
+        return n.elemento;
         // Aquí va su código.
     }
 
@@ -259,6 +390,15 @@ public class Lista<T> implements Coleccion<T> {
      *         no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
+      int r = 0;
+      Nodo n = cabeza;
+      while (n != null) {
+        if(n.elemento.equals(elemento))
+        return r;
+        n = n.siguiente;
+        r++;
+      }
+      return -1;
         // Aquí va su código.
     }
 
@@ -267,6 +407,15 @@ public class Lista<T> implements Coleccion<T> {
      * @return una representación en cadena de la lista.
      */
     @Override public String toString() {
+      if (esVacia())
+      return  "[]";
+      String r  = "[" + cabeza.elemento.toString();
+      Nodo n = cabeza.siguiente;
+      while (n != null) {
+        r += ", " + n.elemento.toString();
+        n = n.siguiente;
+      }
+      return r + "]";
         // Aquí va su código.
     }
 
@@ -280,6 +429,19 @@ public class Lista<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
+        if (lista == null || longitud != lista.longitud)
+            return false;
+        Nodo n = cabeza;
+        Nodo m = lista.cabeza;
+        while (n != null) {
+           if (n.elemento.equals(m.elemento)) {
+            n = n.siguiente;
+            m = m.siguiente;
+          } else {
+            return false;
+          }
+        }
+        return true;
         // Aquí va su código.
     }
 
@@ -308,8 +470,47 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copia de la lista, pero ordenada.
      */
     public Lista<T> mergeSort(Comparator<T> comparador) {
+      if (this.esVacia() || this.longitud == 1)
+            return this;
+        Lista<T> li = new Lista<T>();
+        Lista<T> ld = new Lista<T>();
+        Nodo n = this.cabeza;
+        for (int i = 0; i < this.longitud; i++) {
+            if (i < this.longitud/2)
+                li.agregaFinal(n.elemento);
+            else
+                ld.agregaFinal(n.elemento);
+            n = n.siguiente;
+        }
+        return mezcla(comparador, li.mergeSort(comparador),
+                      ld.mergeSort(comparador));
         // Aquí va su código.
     }
+    /* Método auxiliar para mezclar los elementos de manera ordenada. */
+  private Lista<T> mezcla(Comparator<T> comparador, Lista<T> l1, Lista<T> l2)
+  {
+      Lista<T> r = new Lista<T>();
+      Nodo i = l1.cabeza;
+      Nodo j = l2.cabeza;
+      while (i != null && j != null) {
+          if (comparador.compare(i.elemento, j.elemento) <= 0) {
+              r.agregaFinal(i.elemento);
+              i = i.siguiente;
+          } else {
+              r.agregaFinal(j.elemento);
+              j = j.siguiente;
+          }
+      }
+      while (i != null) {
+          r.agregaFinal(i.elemento);
+          i = i.siguiente;
+      }
+      while (j != null) {
+          r.agregaFinal(j.elemento);
+          j = j.siguiente;
+      }
+      return r;
+  }
 
     /**
      * Regresa una copia de la lista recibida, pero ordenada. La lista recibida
@@ -333,6 +534,13 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
+      Nodo n = cabeza;
+      while (n != null) {
+        if (comparador.compare(n.elemento, elemento) == 0)
+           return true;
+           n = n.siguiente;
+      }
+      return false;
         // Aquí va su código.
     }
 
diff --git a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
index 8864077..db600ef 100644
--- a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
@@ -22,7 +22,7 @@ public abstract class MeteSaca<T> {
          * @param elemento el elemento del nodo.
          */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
     }
 
@@ -43,7 +43,13 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T saca() {
-        // Aquí va su código.
+        if (cabeza == null)
+            throw new NoSuchElementException();
+        T r = cabeza.elemento;
+        cabeza = cabeza.siguiente;
+        if (cabeza == null)
+            rabo = null;
+        return r;
     }
 
     /**
@@ -53,16 +59,18 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T mira() {
-        // Aquí va su código.
+        if (cabeza == null)
+            throw new NoSuchElementException();
+        return cabeza.elemento;
     }
 
     /**
      * Nos dice si la estructura está vacía.
-     * @return <code>true</code> si la estructura no tiene elementos,
-     *         <code>false</code> en otro caso.
+     * @return <tt>true</tt> si la estructura no tiene elementos,
+     *         <tt>false</tt> en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        return cabeza == null;
     }
 
     /**
@@ -76,6 +84,17 @@ public abstract class MeteSaca<T> {
         if (object == null || getClass() != object.getClass())
             return false;
         @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
-        // Aquí va su código.
+        Nodo n1 = cabeza;
+        Nodo n2 = m.cabeza;
+        while (n1 != null) {
+            if (n2 == null)
+                return false;
+            else if (n1.elemento.equals(n2.elemento)) {
+                n1 = n1.siguiente;
+                n2 = n2.siguiente;
+            } else
+                return false;
+        }
+        return true;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Pila.java b/src/main/java/mx/unam/ciencias/edd/Pila.java
index fc800e7..e8037fc 100644
--- a/src/main/java/mx/unam/ciencias/edd/Pila.java
+++ b/src/main/java/mx/unam/ciencias/edd/Pila.java
@@ -10,6 +10,15 @@ public class Pila<T> extends MeteSaca<T> {
      * @return una representación en cadena de la pila.
      */
     @Override public String toString() {
+      String r = "";
+        if (cabeza == null)
+            return r;
+        Nodo n = cabeza;
+        while (n != null) {
+            r += n.elemento.toString() + "\n";
+            n = n.siguiente;
+        }
+        return r;
         // Aquí va su código.
     }
 
@@ -20,6 +29,15 @@ public class Pila<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+      Nodo n = new Nodo (elemento);
+      if (cabeza == null)
+          cabeza = rabo = n;
+      else {
+        n.siguiente = cabeza;
+        cabeza = n;
+      }
         // Aquí va su código.
     }
 }
