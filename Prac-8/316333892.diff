diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java b/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
index 305bae2..ae26802 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
@@ -22,6 +22,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @param elemento el elemento del vértice.
          */
         public VerticeAVL(T elemento) {
+          super(elemento);
             // Aquí va su código.
         }
 
@@ -30,6 +31,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @return la altura del vértice.
          */
         @Override public int altura() {
+          return altura;
             // Aquí va su código.
         }
 
@@ -38,6 +40,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @return una representación en cadena del vértice AVL.
          */
         @Override public String toString() {
+          return elemento.toString() + " " + altura + "/" + balance(this);
             // Aquí va su código.
         }
 
@@ -46,7 +49,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * <em>recursiva</em>.
          * @param objeto el objeto con el cual se comparará el vértice.
          * @return <code>true</code> si el objeto es instancia de la clase
-         *         {@link VerticeAVL}, su elemento es igual al elemento de éste
+         *         {@link VerticeAVL}, su elemento es igual al elemento de
          *         vértice, los descendientes de ambos son recursivamente
          *         iguales, y las alturas son iguales; <code>false</code> en
          *         otro caso.
@@ -55,6 +58,7 @@ public class ArbolAVL<T extends Comparable<T>>
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") VerticeAVL vertice = (VerticeAVL)objeto;
+            return (altura == vertice.altura && super.equals(objeto));
             // Aquí va su código.
         }
     }
@@ -80,6 +84,7 @@ public class ArbolAVL<T extends Comparable<T>>
      * @return un nuevo vértice con el elemento recibido dentro del mismo.
      */
     @Override protected Vertice nuevoVertice(T elemento) {
+      return new VerticeAVL(elemento);
         // Aquí va su código.
     }
 
@@ -90,8 +95,13 @@ public class ArbolAVL<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
+      super.agrega(elemento);
+        rebalanceo(verticeAVL(ultimoAgregado.padre));
         // Aquí va su código.
     }
+    private VerticeAVL verticeAVL(VerticeArbolBinario<T> vertice) {
+      return (VerticeAVL) vertice;
+    }
 
     /**
      * Elimina un elemento del árbol. El método elimina el vértice que contiene
@@ -99,8 +109,59 @@ public class ArbolAVL<T extends Comparable<T>>
      * @param elemento el elemento a eliminar del árbol.
      */
     @Override public void elimina(T elemento) {
+      VerticeAVL v = verticeAVL(super.busca(elemento));
+        if (v == null)
+            return;
+        elementos--;
+        if (v.izquierdo != null && v.derecho != null)
+            v = verticeAVL(intercambiaEliminable(v));
+        eliminaVertice(v);
+        rebalanceo(verticeAVL(v.padre));
         // Aquí va su código.
     }
+    private void rebalanceo(VerticeAVL v) {
+       if (v == null)
+           return;
+       actualiza(v);
+       if (balance(v) == -2) {
+           VerticeAVL q = verticeAVL(v.derecho);
+           if (balance(q) == 1) {
+               super.giraDerecha(q);
+               actualiza(q);
+               q = verticeAVL(v.derecho);
+           }
+           super.giraIzquierda(v);
+           actualiza(v);
+       } else if (balance(v) == 2) {
+           VerticeAVL p = verticeAVL(v.izquierdo);
+           if (balance(v) == -1) {
+               super.giraIzquierda(p);
+               actualiza(p);
+               p = verticeAVL(v.izquierdo);
+           }
+           super.giraDerecha(v);
+           actualiza(v);
+       }
+       rebalanceo(verticeAVL(v.padre));
+   }
+
+   private int balance(VerticeAVL v) {
+        if (v == null)
+            return 0;
+        return altura(verticeAVL(v.izquierdo)) - altura(verticeAVL(v.derecho));
+    }
+
+    private int altura(VerticeAVL v) {
+        if (v == null)
+            return -1;
+        return v.altura;
+    }
+
+    private void actualiza(VerticeAVL v) {
+        v.altura = 1 +
+        Integer.max(altura(verticeAVL(v.izquierdo)), altura(verticeAVL(v.derecho)));
+    }
+
 
     /**
      * Lanza la excepción {@link UnsupportedOperationException}: los árboles AVL
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
index c3893e9..22455a1 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -29,7 +29,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @param elemento el elemento del vértice.
          */
         public Vertice(T elemento) {
-            // Aquí va su código.
+          this.elemento = elemento;
         }
 
         /**
@@ -38,7 +38,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayPadre() {
-            // Aquí va su código.
+          return this.padre != null;
         }
 
         /**
@@ -47,7 +47,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayIzquierdo() {
-            // Aquí va su código.
+          return this.izquierdo != null;
         }
 
         /**
@@ -56,7 +56,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayDerecho() {
-            // Aquí va su código.
+          return this.derecho != null;
         }
 
         /**
@@ -65,7 +65,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
         @Override public VerticeArbolBinario<T> padre() {
-            // Aquí va su código.
+          if(this.hayPadre())
+            return this.padre;
+          throw new NoSuchElementException();
         }
 
         /**
@@ -74,7 +76,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
         @Override public VerticeArbolBinario<T> izquierdo() {
-            // Aquí va su código.
+          if(this.hayIzquierdo())
+            return this.izquierdo;
+          throw new NoSuchElementException();
         }
 
         /**
@@ -83,7 +87,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
         @Override public VerticeArbolBinario<T> derecho() {
-            // Aquí va su código.
+          if(this.hayDerecho())
+            return this.derecho;
+          throw new NoSuchElementException();
         }
 
         /**
@@ -91,7 +97,10 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+          return (this == null) ? -1 : (this.izquierdo != null && this.derecho != null)
+                                ? (Integer.max(this.izquierdo.altura(), this.derecho.altura()) + 1)
+                                : (this.izquierdo == null && this.derecho != null) ? (this.derecho.altura() + 1)
+                                : (this.izquierdo != null && this.derecho == null) ? this.izquierdo.altura() + 1 : 0;
         }
 
         /**
@@ -99,7 +108,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la profundidad del vértice.
          */
         @Override public int profundidad() {
-            // Aquí va su código.
+          return (hayPadre()) ? 1 + padre.profundidad() : 0;
         }
 
         /**
@@ -107,7 +116,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el elemento al que apunta el vértice.
          */
         @Override public T get() {
-            // Aquí va su código.
+          return this.elemento;
         }
 
         /**
@@ -124,7 +133,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
-            // Aquí va su código.
+            return raiz.get().equals(vertice.get()) && equals(raiz.izquierdo, vertice.izquierdo)
+                && equals(raiz.derecho, vertice.derecho);
+        }
+
+        private boolean equals(Vertice i, Vertice d) {
+            return (i == null && d == null) ? true :(i != null && d == null || i == null && d != null)
+                                            ? false : (i.get().equals(d.get())
+                                                    && equals(i.izquierdo, d.izquierdo)
+                                                    && equals(i.derecho, d.derecho));
         }
 
         /**
@@ -132,7 +149,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return una representación en cadena del vértice.
          */
         public String toString() {
-            // Aquí va su código.
+          return String.valueOf(this.elemento);
         }
     }
 
@@ -153,7 +170,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *        binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-        // Aquí va su código.
+      for(T t : coleccion)
+        this.agrega(t);
     }
 
     /**
@@ -166,7 +184,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return un nuevo vértice con el elemento recibido dentro del mismo.
      */
     protected Vertice nuevoVertice(T elemento) {
-        // Aquí va su código.
+        return new Vertice(elemento);
     }
 
     /**
@@ -175,7 +193,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return la altura del árbol.
      */
     public int altura() {
-        // Aquí va su código.
+      return (raiz == null) ? -1 : raiz.altura();
     }
 
     /**
@@ -183,7 +201,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el número de elementos en el árbol.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return elementos;
     }
 
     /**
@@ -193,7 +211,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        return (busca(elemento) != null) ? true : false;
     }
 
     /**
@@ -204,7 +222,19 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>null</code> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return (raiz == null) ? null : (raiz.elemento.equals(elemento)) ? raiz : busca(raiz,elemento);
+    }
+
+    private Vertice busca(Vertice v, T elemento) {
+        if(v == null)
+          return null;
+        if(elemento.equals(v.elemento))
+          return v;
+        Vertice aux = (Vertice)busca(v.izquierdo,elemento);
+        if(aux != null)
+          return aux;
+        aux = (Vertice)busca(v.derecho,elemento);
+          return aux;
     }
 
     /**
@@ -213,7 +243,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el árbol es vacío.
      */
     public VerticeArbolBinario<T> raiz() {
-        // Aquí va su código.
+        if (raiz == null)
+            throw new NoSuchElementException();
+        return raiz;
     }
 
     /**
@@ -222,14 +254,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return raiz == null;
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        raiz = null;
+        elementos = 0;
     }
 
     /**
@@ -243,7 +276,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             return false;
         @SuppressWarnings("unchecked")
             ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
-        // Aquí va su código.
+        return esVacia() || raiz.equals(arbol.raiz);
     }
 
     /**
@@ -251,7 +284,49 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return una representación en cadena del árbol.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        if(raiz == null)
+          return "";
+        int altura = altura() + 1;
+        int[] a = new int[altura];
+        for(int i = 0; i < altura; i++)
+          a[i] = 0;
+        return toString(raiz, 0, a);
+    }
+
+    private String toString(Vertice v, int nivel, int[] arreglo){
+        String s = v.toString() + "\n";
+        arreglo[nivel] = 1;
+        if(v.hayIzquierdo() && v.hayDerecho()){
+         s += dibujaEspacios(nivel,arreglo);
+         s += "├─›";
+         s += toString(v.izquierdo, nivel+1, arreglo);
+         s += dibujaEspacios(nivel,arreglo);
+         s += "└─»";
+         arreglo[nivel] = 0;
+         s += toString(v.derecho, nivel+1, arreglo);
+        }else if(v.hayIzquierdo()){
+         s += dibujaEspacios(nivel,arreglo);
+         s += "└─›";
+         arreglo[nivel] = 0;
+         s += toString(v.izquierdo,nivel+1,arreglo);
+        }else if(v.hayDerecho()){
+         s += dibujaEspacios(nivel,arreglo);
+         s += "└─»";
+         arreglo[nivel] = 0;
+         s += toString(v.derecho, nivel+1, arreglo);
+        }
+        return s;
+     }
+
+     private String dibujaEspacios(int nivel, int[] arreglo){
+        String s = "";
+        for(int i = 0; i < nivel; i++){
+        if(arreglo[i] == 1)
+          s += "│  ";
+        else
+          s += "   ";
+        }
+        return s;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index 97a2ea0..8607959 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -18,16 +18,26 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
 
         /* Inicializa al iterador. */
         public Iterador() {
+          cola = new Cola<Vertice>();
+          if (raiz != null)
+              cola.mete(raiz);
             // Aquí va su código.
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
+          return !cola.esVacia();
             // Aquí va su código.
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
+          Vertice v = cola.saca();
+            if (v.hayIzquierdo())
+                cola.mete(v.izquierdo);
+            if (v.hayDerecho())
+                cola.mete(v.derecho);
+            return v.get();
             // Aquí va su código.
         }
     }
@@ -56,6 +66,29 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
+      if (elemento == null)
+            throw new IllegalArgumentException();
+        Vertice v = nuevoVertice(elemento);
+        elementos++;
+        if (esVacia())
+            raiz = v;
+        else {
+            Cola<Vertice> cola = new Cola<Vertice>();
+            cola.mete(raiz);
+            while (!cola.esVacia()) {
+                Vertice t = cola.saca();
+                if (!t.hayIzquierdo() || !t.hayDerecho()) {
+                    v.padre = t;
+                    if (!t.hayIzquierdo())
+                        t.izquierdo = v;
+                    else if (!t.hayDerecho())
+                        t.derecho = v;
+                    break;
+                }
+                cola.mete(t.izquierdo);
+                cola.mete(t.derecho);
+            }
+        }
         // Aquí va su código.
     }
 
@@ -66,8 +99,38 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
+      Vertice e = vertice(busca(elemento));
+        if (e == null)
+            return;
+        else {
+            elementos--;
+            if (elementos == 0)
+                raiz = null;
+            else {
+                Vertice u = bfsUltimo();
+                e.elemento = u.elemento;
+                if (u.padre.izquierdo == u)
+                    u.padre.izquierdo = null;
+                u.padre.derecho = null;
+                u.elemento = null;
+            }
+        }
         // Aquí va su código.
     }
+    private Vertice bfsUltimo() {
+        Cola<Vertice> cola = new Cola<Vertice>();
+        cola.mete(raiz);
+        Vertice ultimo = null;
+        while (!cola.esVacia()) {
+            Vertice v = cola.saca();
+            if (v.hayIzquierdo())
+                cola.mete(v.izquierdo);
+            if (v.hayDerecho())
+                cola.mete(v.derecho);
+            ultimo = v;
+        }
+        return ultimo;
+    }
 
     /**
      * Regresa la altura del árbol. La altura de un árbol binario completo
@@ -75,6 +138,10 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @return la altura del árbol.
      */
     @Override public int altura() {
+      if (raiz == null)
+            return -1;
+        int r = (int)Math.floor(Math.log(elementos) / Math.log(2));
+        return r;
         // Aquí va su código.
     }
 
@@ -84,6 +151,20 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
+      if (esVacia())
+          return;
+      else {
+          Cola<Vertice> cola = new Cola<Vertice>();
+          cola.mete(raiz);
+          while (!cola.esVacia()) {
+              Vertice v = cola.saca();
+              accion.actua(v);
+              if (v.hayIzquierdo())
+                  cola.mete(v.izquierdo);
+              if (v.hayDerecho())
+                  cola.mete(v.derecho);
+          }
+      }
         // Aquí va su código.
     }
 
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index ea913b1..cb2575b 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -25,17 +25,31 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
 
         /* Inicializa al iterador. */
         public Iterador() {
-            // Aquí va su código.
+            pila = new Pila<Vertice>();
+            Vertice aux = raiz;
+            while(aux != null){
+              pila.mete(aux);
+              aux = aux.izquierdo;
+          }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !pila.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
         @Override public T next() {
-            // Aquí va su código.
+            Vertice v1 = pila.saca();
+            Vertice v2 = v1;
+            if(v2.hayDerecho()){
+              v2 = v2.derecho;
+              while(v2 != null){
+                pila.mete(v2);
+                v2 = v2.izquierdo;
+              }
+            }
+            return v1.elemento;
         }
     }
 
@@ -69,7 +83,34 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if(elemento == null)
+          throw new IllegalArgumentException();
+        if(raiz == null){
+           raiz = nuevoVertice(elemento);
+        ultimoAgregado = raiz;
+        elementos++;
+        return;
+        }
+        agrega(elemento, raiz);
+    }
+
+    private void agrega(T elemento, Vertice vertice){
+        if(elemento.compareTo(vertice.elemento) <= 0){
+          if(!vertice.hayIzquierdo()){
+            vertice.izquierdo = nuevoVertice(elemento);
+            vertice.izquierdo.padre = vertice;
+            ultimoAgregado = vertice.izquierdo;
+            elementos++;
+            }else
+             agrega(elemento, vertice.izquierdo);
+            }else{if(!vertice.hayDerecho()){
+                  vertice.derecho = nuevoVertice(elemento);
+                  vertice.derecho.padre = vertice;
+                  ultimoAgregado = vertice.derecho;
+                  elementos++;
+            }else
+            agrega(elemento, vertice.derecho);
+        }
     }
 
     /**
@@ -79,7 +120,13 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        Vertice v = vertice(busca(elemento));
+        if (v == null)
+            return;
+        elementos--;
+        if (v.izquierdo != null && v.derecho != null)
+            v = intercambiaEliminable(v);
+        eliminaVertice(v);
     }
 
     /**
@@ -92,7 +139,15 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         de <code>null</code>.
      */
     protected Vertice intercambiaEliminable(Vertice vertice) {
-        // Aquí va su código.
+        Vertice v = maximoEnSubArbol(vertice.izquierdo);
+        vertice.elemento = v.elemento;
+        return v;
+    }
+
+    private Vertice maximoEnSubArbol(Vertice v) {
+      if (v.derecho == null)
+          return v;
+      return maximoEnSubArbol(v.derecho);
     }
 
     /**
@@ -102,7 +157,23 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *                distinto de <code>null</code>.
      */
     protected void eliminaVertice(Vertice vertice) {
-        // Aquí va su código.
+          Vertice u = hijo(vertice);
+          Vertice p = vertice.padre;
+          if (p != null) {
+              if (p.izquierdo == vertice)
+                  p.izquierdo = u;
+              if (p.derecho == vertice)
+                  p.derecho = u;
+          } else
+              raiz = u;
+          if (u != null)
+              u.padre = p;
+    }
+
+    private Vertice hijo(Vertice v) {
+      if (v.izquierdo != null)
+          return v.izquierdo;
+      return v.derecho;
     }
 
     /**
@@ -113,7 +184,14 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         encuentra; <code>null</code> en otro caso.
      */
     @Override public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca(raiz,elemento);
+
+    }
+    private VerticeArbolBinario<T> busca(Vertice vertice, T elemento){
+        return (vertice == null || elemento == null) ? null :
+               (elemento.compareTo(vertice.get()) == 0) ? vertice :
+               (elemento.compareTo(vertice.get()) < 0) ? busca(vertice.izquierdo, elemento)
+                                                       : busca(vertice.derecho, elemento);
     }
 
     /**
@@ -128,7 +206,7 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         elemento al árbol.
      */
     public VerticeArbolBinario<T> getUltimoVerticeAgregado() {
-        // Aquí va su código.
+        return ultimoAgregado;
     }
 
     /**
@@ -137,7 +215,25 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        Vertice v = vertice(vertice);
+        if(!v.hayIzquierdo())
+          return;
+        Vertice pv = v.padre;
+        Vertice vi = v.izquierdo;
+        Vertice vd = vi.derecho;
+        v.padre = vi;
+        vi.derecho = v;
+        if(vd != null)
+          vd.padre = v;
+        v.izquierdo = vd;
+        vi.padre = pv;
+        if(pv == null)
+          raiz = vi;
+        else
+          if(pv.izquierdo == v)
+            pv.izquierdo = vi;
+          else
+            pv.derecho = vi;
     }
 
     /**
@@ -146,7 +242,25 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        Vertice v = vertice(vertice);
+        if(!v.hayDerecho())
+          return;
+        Vertice pv = v.padre;
+        Vertice d = v.derecho;
+        Vertice di = d.izquierdo;
+        v.padre = d;
+        d.izquierdo = v;
+        if(di != null)
+          di.padre = v;
+        v.derecho = di;
+        d.padre = pv;
+        if(pv == null)
+          raiz = d;
+        else
+          if(pv.izquierdo == v)
+            pv.izquierdo = d;
+          else
+            pv.derecho = d;
     }
 
     /**
@@ -155,7 +269,14 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPre(raiz,accion);
+    }
+    private void dfsPre(Vertice vertice, AccionVerticeArbolBinario<T> accion){
+        if (vertice == null)
+            return;
+        accion.actua(vertice);
+        dfsPre(vertice.izquierdo,accion);
+        dfsPre(vertice.derecho,accion);
     }
 
     /**
@@ -164,7 +285,14 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsIn(raiz,accion);
+    }
+    private void dfsIn(Vertice vertice, AccionVerticeArbolBinario<T> accion){
+        if (vertice == null)
+            return;
+        dfsIn(vertice.izquierdo,accion);
+        accion.actua(vertice);
+        dfsIn(vertice.derecho,accion);
     }
 
     /**
@@ -173,7 +301,14 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPost(raiz,accion);
+    }
+    private void dfsPost(Vertice vertice, AccionVerticeArbolBinario<T> accion){
+        if (vertice == null)
+            return;
+        dfsPost(vertice.izquierdo,accion);
+        dfsPost(vertice.derecho,accion);
+        accion.actua(vertice);
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
index 3bdf8f5..614797a 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
@@ -32,6 +32,8 @@ public class ArbolRojinegro<T extends Comparable<T>>
          */
         public VerticeRojinegro(T elemento) {
             // Aquí va su código.
+            super(elemento);
+            this.color = color.NINGUNO;
         }
 
         /**
@@ -40,6 +42,8 @@ public class ArbolRojinegro<T extends Comparable<T>>
          */
         public String toString() {
             // Aquí va su código.
+            return (color == Color.ROJO) ? "R{" + String.valueOf(elemento) + "}":
+            "N{" + String.valueOf(elemento) + "}";
         }
 
         /**
@@ -58,6 +62,8 @@ public class ArbolRojinegro<T extends Comparable<T>>
             @SuppressWarnings("unchecked")
                 VerticeRojinegro vertice = (VerticeRojinegro)objeto;
             // Aquí va su código.
+            return (color == vertice.color && super.equals(objeto));
+
         }
     }
 
@@ -85,6 +91,12 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     @Override protected Vertice nuevoVertice(T elemento) {
         // Aquí va su código.
+        return new VerticeRojinegro(elemento);
+    }
+
+    private VerticeRojinegro verticeRojinegro(VerticeArbolBinario<T> vertice) {
+      VerticeRojinegro v = (VerticeRojinegro)vertice;
+      return v;
     }
 
     /**
@@ -96,6 +108,9 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     public Color getColor(VerticeArbolBinario<T> vertice) {
         // Aquí va su código.
+        if(vertice.getClass() != VerticeRojinegro.class )
+                throw new ClassCastException();
+        return verticeRojinegro(vertice).color;
     }
 
     /**
@@ -106,6 +121,131 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        super.agrega(elemento);
+        VerticeRojinegro vr = (VerticeRojinegro)super.getUltimoVerticeAgregado();
+        vr.color = Color.ROJO;
+        rebalanceoAgrega(vr);
+    }
+
+    //metodo auxiliar para rebalancear un arbol
+    private void rebalanceoAgrega(VerticeRojinegro vertice){
+        //caso 1
+        if(!vertice.hayPadre()){
+            vertice.color= Color.NEGRO;
+            return;
+        }
+
+        //Caso 2
+        VerticeRojinegro p = getPadre(vertice);
+        if(esNegro(p))
+           return;
+
+        //caso3
+        VerticeRojinegro a = getAbuelo(vertice);
+        //en esta parte sacamos al tio
+
+        VerticeRojinegro t = getTio(vertice);
+        if(esRojo(t)){
+            t.color = Color.NEGRO;
+            p.color = Color.NEGRO;
+            a.color = Color.ROJO;
+            rebalanceoAgrega(a);
+        }else{
+            //caso 4
+            VerticeRojinegro aux = p;
+            if (a.izquierdo == p && p.derecho == vertice){
+                super.giraIzquierda(p);
+                //actualiza vertices
+                p = vertice;
+                vertice = aux;
+            }
+
+            if (a.derecho==p&&p.izquierdo == vertice){
+            super.giraDerecha(p);
+            //actualiza verices
+            p = vertice;
+            vertice = aux;
+            }
+            //caso 5
+            p.color = Color.NEGRO;
+            a.color = Color.ROJO;
+            if (vertice==p.izquierdo){
+                super.giraDerecha(a);
+            }else{
+              super.giraIzquierda(a);
+            }
+        }
+
+    }
+
+    /**
+     * Método auxiliar que nos dice si el vértice es rojo.
+     */
+    private boolean esRojo(VerticeRojinegro v){
+      return(v != null && v.color == Color.ROJO);
+    }
+
+    /**
+     * Método auxiliar que nos dice si el vértice es negro.
+     */
+    private boolean esNegro(VerticeRojinegro v){
+      return(v == null || v.color == Color.NEGRO);
+    }
+
+    /**
+     *Método auxiliar para conseguir el padre del vértice.
+     */
+    private VerticeRojinegro getPadre(VerticeRojinegro v){
+      VerticeRojinegro p = verticeRojinegro(v.padre);
+      return p;
+    }
+
+    /**
+     *Método auxiliar para conseguir el abuelo del vértice.
+     */
+    private VerticeRojinegro getAbuelo(VerticeRojinegro v){
+      VerticeRojinegro p = verticeRojinegro(v.padre);
+      return verticeRojinegro(p.padre);
+    }
+
+    /**
+     *Método auxiliar para conseguir el tío del vértice.
+     */
+     private VerticeRojinegro getTio(VerticeRojinegro v){
+       VerticeRojinegro a = getAbuelo(v);
+       if(v.padre == a.izquierdo)
+        return verticeRojinegro(a.derecho);
+       else
+        return verticeRojinegro(a.izquierdo);
+     }
+
+   /**
+    *Método auxiliar para conseguir el hermano del vértice.
+    */
+    private VerticeRojinegro getHermano(VerticeRojinegro v){
+       VerticeRojinegro p = verticeRojinegro(v.padre);
+       if(v == p.izquierdo)
+         return verticeRojinegro(p.derecho);
+       else
+        return verticeRojinegro(p.izquierdo);
+     }
+
+    /**
+      *Método auxiliar para buscar un elemento en el árbol.
+      *@param vertice en el que vamos a buscar.
+      *@param elemento que vamos a buscar en el árbol.
+      *@return el vértice en el que se encuentra el elemento, si
+      *es que se encuentra.
+      */
+    private VerticeRojinegro buscaElemento(VerticeRojinegro v,T elemento){
+      if(v == null)
+        return null;
+      if(elemento.equals(v.elemento))
+        return v;
+      if(elemento.compareTo(v.elemento) < 0)
+        return buscaElemento(verticeRojinegro(v.izquierdo), elemento);
+      else
+        return buscaElemento(verticeRojinegro(v.derecho), elemento);
     }
 
     /**
@@ -116,6 +256,160 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        VerticeRojinegro v = buscaElemento(verticeRojinegro(super.raiz),elemento);
+        //Buscamos el elemento a eliminar.
+        if(v == null)
+        return;
+
+        VerticeRojinegro aux = null;
+        if(v.hayIzquierdo()){
+            aux = v;
+            v = intercambiaVertice(verticeRojinegro(v.izquierdo));
+            aux.elemento = v.elemento;
+            aux = null;
+        }
+
+        if(!v.hayIzquierdo() && !v.hayDerecho()){
+            v.izquierdo = nuevoVertice(null);
+            aux = verticeRojinegro(v.izquierdo);
+            aux.padre = v;
+            aux.color = Color.NEGRO;
+        }
+
+        VerticeRojinegro h = null;
+        if(v.hayIzquierdo())
+            h = verticeRojinegro(v.izquierdo);
+        else
+            h = verticeRojinegro(v.derecho);
+
+        desconecta(h,v);
+
+        if(esRojo(h) || esRojo(v)){
+            h.color = Color.NEGRO;
+        }else{
+            h.color = Color.NEGRO;
+            rebalanceaElimina(h);
+        }
+
+        if(aux != null){
+            if(!aux.hayPadre()){
+              super.raiz = null;
+              ultimoAgregado = null;
+              aux = null;
+          }else if(aux.padre.derecho == aux){
+              aux.padre.derecho = null;
+          }else{
+              aux.padre.izquierdo = null;
+          }
+        }
+        elementos--;
+    }
+
+    /**
+     *Método auxiliar para reemplazar el vértice por uno de sus hijos.
+     *@param hijo por el cuál será reemplazado el vértice.
+     *@param v vértice que se eliminará.
+     */
+    private void desconecta(VerticeRojinegro hijo, VerticeRojinegro v){
+        if(!v.hayPadre()){
+          raiz = hijo;
+          raiz.padre = null;
+          return;
+        }
+        hijo.padre = v.padre;
+        if(v == v.padre.izquierdo){
+          if(v.izquierdo == hijo)
+            v.padre.izquierdo = v.izquierdo;
+          else
+            v.padre.izquierdo = v.derecho;
+        }
+        if(v == v.padre.derecho){
+          if(v.izquierdo == hijo)
+            v.padre.derecho = v.izquierdo;
+          else
+            v.padre.derecho = v.derecho;
+        }
+    }
+
+    /**
+     *Método auxiliar para intercambiar un vértice con el máximo.
+     */
+    private VerticeRojinegro intercambiaVertice(VerticeRojinegro vertice){
+        if(vertice.hayDerecho())
+          return intercambiaVertice(verticeRojinegro(vertice.derecho));
+        else
+          return vertice;
+    }
+
+    /**
+     *Método auxiliar privado para rebalancear el árbol siempre que se elimina
+     *un elemento
+     *@param v que es el vértice de color negro sobre el que se balanceará
+     *el árbol.
+     */
+    private void rebalanceaElimina(VerticeRojinegro v){
+        //Caso 1:
+        if(!v.hayPadre()){
+          v.color = Color.NEGRO;
+          raiz = v;
+          return;
+        }
+        VerticeRojinegro p = getPadre(v);
+        VerticeRojinegro h = getHermano(v);
+
+        //Caso 2:
+        if(esRojo(h) && esNegro(p)){
+          p.color = Color.ROJO;
+          h.color = Color.NEGRO;
+          if(v == p.izquierdo)
+            super.giraIzquierda(p);
+          else
+            super.giraDerecha(p);
+          h = getHermano(v);
+          p = getPadre(v);
+        }
+
+        VerticeRojinegro hi = verticeRojinegro(h.izquierdo);
+        VerticeRojinegro hd = verticeRojinegro(h.derecho);
+        //Caso 3:
+        if(esNegro(p) && esNegro(h) && esNegro(hi) && esNegro(hd)){
+          h.color = Color.ROJO;
+          rebalanceaElimina(p);
+          return;
+        }
+
+        //Caso 4:
+        if(esNegro(h) && esNegro(hi) && esNegro(hd) && esRojo(p)){
+          h.color = Color.ROJO;
+          p.color = Color.NEGRO;
+          return;
+        }
+
+        //Caso 5:
+        if(v == p.izquierdo && esRojo(hi) && esNegro(hd) && esNegro(h)){
+          h.color = Color.ROJO;
+          hi.color = Color.NEGRO;
+          super.giraDerecha(h);
+        }else if(v == p.derecho && esNegro(hi) && esRojo(hd) && esNegro(h)){
+          h.color = Color.ROJO;
+          hd.color = Color.NEGRO;
+          super.giraIzquierda(h);
+        }
+
+        h = getHermano(v);
+        hi = verticeRojinegro(h.izquierdo);
+        hd = verticeRojinegro(h.derecho);
+
+        //Caso 6:
+        h.color = p.color;
+        p.color = Color.NEGRO;
+        if(v == p.izquierdo){
+          hd.color = Color.NEGRO;
+          super.giraIzquierda(p);
+        }else{
+          hi.color = Color.NEGRO;
+          super.giraDerecha(p);
+        }
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Arreglos.java b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
index 641317c..0390396 100644
--- a/src/main/java/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
@@ -18,6 +18,7 @@ public class Arreglos {
      */
     public static <T> void
     quickSort(T[] arreglo, Comparator<T> comparador) {
+      quickSort(arreglo, comparador, 0, arreglo.length -1);
         // Aquí va su código.
     }
 
@@ -30,6 +31,27 @@ public class Arreglos {
     quickSort(T[] arreglo) {
         quickSort(arreglo, (a, b) -> a.compareTo(b));
     }
+    /*Método auxiliar para quickSort. */
+    private static <T> void
+    quickSort(T[] arreglo, Comparator<T> comparador, int inicio, int fin) {
+        if (fin <= inicio)
+            return;
+        int i = inicio + 1;
+        int j = fin;
+        while (i < j)
+            if (comparador.compare(arreglo[i], arreglo[inicio]) > 0 &&
+                comparador.compare(arreglo[j], arreglo[inicio]) <= 0)
+                intercambia(arreglo, i++, j--);
+            else if (comparador.compare(arreglo[i], arreglo[inicio]) <= 0)
+                i++;
+            else
+                j--;
+        if (comparador.compare(arreglo[i], arreglo[inicio]) > 0)
+            i--;
+        intercambia(arreglo, inicio, i);
+        quickSort(arreglo, comparador, inicio, i - 1);
+        quickSort(arreglo, comparador, i + 1, fin);
+    }
 
     /**
      * Ordena el arreglo recibido usando SelectionSort.
@@ -39,8 +61,23 @@ public class Arreglos {
      */
     public static <T> void
     selectionSort(T[] arreglo, Comparator<T> comparador) {
+      for (int i = 0; i < arreglo.length; i++) {
+        int m = i;
+        for (int j = i +1; j < arreglo.length; j++)
+           if (comparador.compare(arreglo[m], arreglo[j]) > 0)
+              m = j;
+            intercambia(arreglo, i, m);
+      }
         // Aquí va su código.
     }
+    /* Método auxiliar para intercambiar elementos dentro de un arreglo. */
+private static <T> void intercambia(T[] arreglo, int a, int b) {
+    if (a == b)
+        return;
+    T auxiliar = arreglo[a];
+    arreglo[a] = arreglo[b];
+    arreglo[b] = auxiliar;
+}
 
     /**
      * Ordena el arreglo recibido usando SelectionSort.
@@ -63,6 +100,19 @@ public class Arreglos {
      */
     public static <T> int
     busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
+      quickSort(arreglo, comparador);
+    int inicio = 0;
+    int fin = arreglo.length -1;
+    while (inicio <= fin) {
+        int r = inicio + (fin - inicio)/ 2;
+        if (comparador.compare(arreglo[r], elemento) == 0)
+           return r;
+        else if (comparador.compare(arreglo[r], elemento) < 0)
+           inicio = r + 1;
+        else
+            fin = r - 1;
+    }
+    return -1;
         // Aquí va su código.
     }
 
diff --git a/src/main/java/mx/unam/ciencias/edd/Cola.java b/src/main/java/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..988d21b 100644
--- a/src/main/java/mx/unam/ciencias/edd/Cola.java
+++ b/src/main/java/mx/unam/ciencias/edd/Cola.java
@@ -10,6 +10,15 @@ public class Cola<T> extends MeteSaca<T> {
      * @return una representación en cadena de la cola.
      */
     @Override public String toString() {
+      String r = "";
+        if (cabeza == null)
+            return r;
+        Nodo n = cabeza;
+        while (n != null) {
+            r += n.elemento.toString() + ",";
+            n = n.siguiente;
+        }
+        return r;
         // Aquí va su código.
     }
 
@@ -20,6 +29,15 @@ public class Cola<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+      Nodo n = new Nodo (elemento);
+      if (cabeza == null)
+         cabeza = rabo = n;
+      else {
+        rabo.siguiente = n;
+        rabo = n;
+      }
         // Aquí va su código.
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Grafica.java b/src/main/java/mx/unam/ciencias/edd/Grafica.java
index d435b1c..46a62bf 100644
--- a/src/main/java/mx/unam/ciencias/edd/Grafica.java
+++ b/src/main/java/mx/unam/ciencias/edd/Grafica.java
@@ -18,16 +18,20 @@ public class Grafica<T> implements Coleccion<T> {
         /* Construye un nuevo iterador, auxiliándose de la lista de vértices. */
         public Iterador() {
             // Aquí va su código.
+            iterador = vertices.iterator();
+
         }
 
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
             // Aquí va su código.
+            return iterador.hasNext();
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
             // Aquí va su código.
+            return iterador.next().get();
         }
     }
 
@@ -49,41 +53,55 @@ public class Grafica<T> implements Coleccion<T> {
         /* Crea un nuevo vértice a partir de un elemento. */
         public Vertice(T elemento) {
             // Aquí va su código.
+            this.elemento = elemento;
+            this.color=Color.NINGUNO;
+            this.vecinos = new Lista<>();
         }
 
         /* Regresa el elemento del vértice. */
         @Override public T get() {
             // Aquí va su código.
+            return this.elemento;
         }
 
         /* Regresa el grado del vértice. */
         @Override public int getGrado() {
             // Aquí va su código.
+            return this.vecinos.getElementos();
         }
 
         /* Regresa el color del vértice. */
         @Override public Color getColor() {
             // Aquí va su código.
+            return this.color;
         }
 
         /* Regresa un iterable para los vecinos. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
             // Aquí va su código.
+            return vecinos;
         }
 
         /* Define el índice del vértice. */
         @Override public void setIndice(int indice) {
             // Aquí va su código.
+            this.indice = indice;
         }
 
         /* Regresa el índice del vértice. */
         @Override public int getIndice() {
             // Aquí va su código.
+            return this.indice;
         }
 
         /* Compara dos vértices por distancia. */
         @Override public int compareTo(Vertice vertice) {
             // Aquí va su código.
+            if(distancia > vertice.distancia)
+              return 1;
+            else if(distancia < vertice.distancia)
+              return -1;
+            return 0;
         }
     }
 
@@ -99,26 +117,34 @@ public class Grafica<T> implements Coleccion<T> {
          * peso especificado. */
         public Vecino(Vertice vecino, double peso) {
             // Aquí va su código.
+            this.vecino = vecino;
+            this.peso = peso;
         }
 
         /* Regresa el elemento del vecino. */
         @Override public T get() {
             // Aquí va su código.
+            return this.vecino.get();
         }
 
         /* Regresa el grado del vecino. */
         @Override public int getGrado() {
             // Aquí va su código.
+            return this.vecino.getGrado();
+
         }
 
         /* Regresa el color del vecino. */
         @Override public Color getColor() {
             // Aquí va su código.
+            return this.vecino.getColor();
+
         }
 
         /* Regresa un iterable para los vecinos del vecino. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
             // Aquí va su código.
+            return this.vecino.vecinos;
         }
     }
 
@@ -140,6 +166,8 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public Grafica() {
         // Aquí va su código.
+        this.vertices = new Lista<>();
+        this.aristas = 0;
     }
 
     /**
@@ -149,6 +177,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public int getElementos() {
         // Aquí va su código.
+        return vertices.getElementos();
     }
 
     /**
@@ -157,6 +186,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public int getAristas() {
         // Aquí va su código.
+        return aristas;
     }
 
     /**
@@ -167,6 +197,13 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        if(elemento == null)
+            throw new IllegalArgumentException();
+        for(Vertice v : vertices){
+            if(v.elemento.equals(elemento))
+                throw new IllegalArgumentException();
+        }
+        vertices.agrega(new Vertice(elemento));
     }
 
     /**
@@ -180,6 +217,15 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void conecta(T a, T b) {
         // Aquí va su código.
+        if(!contiene(a) || !contiene(b))
+        throw new NoSuchElementException();
+        if(a.equals(b) || sonVecinos(a, b))
+        throw new IllegalArgumentException();
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        va.vecinos.agrega(new Vecino(vb, 1));
+        vb.vecinos.agrega(new Vecino(va, 1));
+        aristas++;
     }
 
     /**
@@ -194,6 +240,15 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void conecta(T a, T b, double peso) {
         // Aquí va su código.
+        if(!contiene(a) || !contiene(b))
+            throw new NoSuchElementException();
+        if(a.equals(b) || sonVecinos(a,b) || peso < 0)
+            throw new IllegalArgumentException();
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        va.vecinos.agrega(new Vecino(vb, peso));
+        vb.vecinos.agrega(new Vecino(va, peso));
+        aristas++;
     }
 
     /**
@@ -206,6 +261,23 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void desconecta(T a, T b) {
         // Aquí va su código.
+        if(!contiene(a) || !contiene(b))
+          throw new NoSuchElementException();
+        if(a.equals(b) || !sonVecinos(a,b))
+          throw new IllegalArgumentException();
+
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        Vecino vecA_B = null, vecB_A = null;
+        for(Vecino ve : va.vecinos)
+            if(ve.vecino.equals(vb))
+                vecA_B = ve;
+        for (Vecino ve : vb.vecinos)
+            if (ve.vecino.equals(va))
+                vecB_A = ve;
+        va.vecinos.elimina(vecA_B);
+        vb.vecinos.elimina(vecB_A);
+        aristas--;
     }
 
     /**
@@ -215,6 +287,22 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public boolean contiene(T elemento) {
         // Aquí va su código.
+        for(Vertice v : vertices)
+            if(v.get().equals(elemento))
+               return true;
+        return false;
+    }
+
+    /**
+     *Método auxiliar para búsqueda de vértices.
+     *@param e elemento a buscar
+     *@return el vértice con el elemento si lo encuentra.
+     */
+    private Vertice busca(T elemento){
+        for(Vertice v : vertices)
+           if(v.get().equals(elemento))
+              return v;
+        return null;
     }
 
     /**
@@ -226,6 +314,16 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        if(!contiene(elemento))
+            throw new NoSuchElementException();
+        Vertice v = (Vertice) vertice(elemento);
+        for(Vertice ver : vertices)
+            for(Vecino vec : ver.vecinos)
+                if(vec.vecino.equals(v)) {
+                    ver.vecinos.elimina(vec);
+                    aristas--;
+                }
+        vertices.elimina(v);
     }
 
     /**
@@ -238,6 +336,14 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public boolean sonVecinos(T a, T b) {
         // Aquí va su código.
+        if(!contiene(a) || !contiene(b))
+            throw new NoSuchElementException();
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        for(Vecino ve : va.vecinos)
+            if(ve.vecino.equals(vb))
+              return true;
+        return false;
     }
 
     /**
@@ -252,6 +358,16 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public double getPeso(T a, T b) {
         // Aquí va su código.
+        if(!contiene(a) || !contiene(b))
+            throw new NoSuchElementException();
+        if(!sonVecinos(a,b))
+            throw new IllegalArgumentException();
+        Vertice x = (Vertice) vertice(a);
+        Vertice y = (Vertice) vertice(b);
+        for(Vecino v : x.vecinos)
+            if(v.vecino.equals(y))
+                return v.peso;
+        return -1;
     }
 
     /**
@@ -267,6 +383,18 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void setPeso(T a, T b, double peso) {
         // Aquí va su código.
+        if(!contiene(a) || !contiene(b))
+            throw new NoSuchElementException();
+        if(a.equals(b) || !sonVecinos(a,b) || peso <= 0)
+            throw new IllegalArgumentException();
+        Vertice x = busca(a);
+        Vertice y = busca(b);
+        for(Vecino xv : x.vecinos)
+            if(xv.vecino.equals(y))
+                xv.peso = peso;
+        for(Vecino yv : y.vecinos)
+            if(yv.vecino.equals(x))
+                yv.peso = peso;
     }
 
     /**
@@ -277,6 +405,10 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public VerticeGrafica<T> vertice(T elemento) {
         // Aquí va su código.
+        for(Vertice v : vertices)
+            if(v.elemento.equals(elemento))
+               return v;
+        throw new NoSuchElementException();
     }
 
     /**
@@ -287,6 +419,16 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void setColor(VerticeGrafica<T> vertice, Color color) {
         // Aquí va su código.
+        if(vertice == null || (vertice.getClass() != Vertice.class && vertice.getClass() != Vecino.class))
+            throw new IllegalArgumentException();
+        if(vertice.getClass() == Vertice.class) {
+            Vertice v = (Vertice)vertice;
+            v.color = color;
+        }
+        if(vertice.getClass() == Vecino.class) {
+            Vecino v = (Vecino)vertice;
+            v.vecino.color = color;
+        }
     }
 
     /**
@@ -296,6 +438,25 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public boolean esConexa() {
         // Aquí va su código.
+        for(Vertice v : vertices)
+            v.color = Color.ROJO;
+        Cola<Vertice> vert = new Cola<Vertice>();
+        vert.mete(vertices.getPrimero());
+        vertices.getPrimero().color = Color.NEGRO;
+        while(!vert.esVacia()) {
+            Vertice aux = vert.saca();
+            for(Vecino ve : aux.vecinos){
+                if(ve.vecino.color == Color.ROJO) {
+                   ve.vecino.color = Color.NEGRO;
+                   vert.mete(ve.vecino);
+                }
+            }
+        }
+        for(Vertice w: vertices){
+            if(w.color != Color.NEGRO)
+               return false;
+        }
+        return true;
     }
 
     /**
@@ -305,6 +466,8 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void paraCadaVertice(AccionVerticeGrafica<T> accion) {
         // Aquí va su código.
+        for(Vertice v : vertices)
+            accion.actua(v);
     }
 
     /**
@@ -319,6 +482,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void bfs(T elemento, AccionVerticeGrafica<T> accion) {
         // Aquí va su código.
+        recorrido(elemento, accion, new Cola<Grafica<T>.Vertice>());
     }
 
     /**
@@ -333,6 +497,37 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void dfs(T elemento, AccionVerticeGrafica<T> accion) {
         // Aquí va su código.
+        recorrido(elemento, accion, new Pila<Grafica<T>.Vertice>());
+    }
+
+    /**
+     * Auxiliar que recorre ya sea de manera bfs o dfs segun se le pase un MeteSaca y ejecuta una accion.
+     */
+    private void recorrido(T elemento, AccionVerticeGrafica<T> accion, MeteSaca<Grafica<T>.Vertice> metesaca) {
+        if(!contiene(elemento))
+            throw new NoSuchElementException();
+        Vertice v = (Vertice) vertice(elemento);
+        metesaca.mete(v);
+        while(!metesaca.esVacia()) {
+            Vertice vt = metesaca.saca();
+            setColor(vt,Color.ROJO);
+            accion.actua(vt);
+            for(Vecino ve : vt.vecinos)
+                if(ve.vecino.color != Color.ROJO) {
+                   setColor(ve, Color.ROJO);
+                   metesaca.mete(ve.vecino);
+                }
+        }
+        paraCadaVertice(vertice -> this.setColor(vertice, Color.NINGUNO));
+    }
+
+    /**
+     * Asigna el color al vértice.
+     * @param ver vértice a asignar color.
+     * @param c el color que se le asignará al vértice.
+     */
+    private void setColor(Vertice ver, Color c) {
+        ver.color = c;
     }
 
     /**
@@ -342,6 +537,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public boolean esVacia() {
         // Aquí va su código.
+        return vertices.esVacia();
     }
 
     /**
@@ -349,6 +545,8 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public void limpia() {
         // Aquí va su código.
+        vertices.limpia();
+        aristas = 0;
     }
 
     /**
@@ -357,6 +555,23 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public String toString() {
         // Aquí va su código.
+        Lista<T> lista = new Lista<T>();
+        for(Vertice rojo : vertices)
+            rojo.color = Color.ROJO;
+        String cadena = "{";
+        String aristas = "{";
+        for(Vertice v : vertices) {
+            cadena += v.elemento + ", ";
+            for(Vecino ady : v.vecinos) {
+                if(ady.getColor() == Color.ROJO)
+                   aristas += "(" + v.get() + ", " + ady.get() + "), ";
+                v.color = Color.NEGRO;
+            }
+            lista.agrega(v.elemento);
+        }
+        for(Vertice nulo : vertices)
+            nulo.color = Color.NINGUNO;
+        return cadena + "}, " + aristas + "}";
     }
 
     /**
@@ -369,7 +584,22 @@ public class Grafica<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Grafica<T> grafica = (Grafica<T>)objeto;
-        // Aquí va su código.
+        if((getElementos() != grafica.getElementos()) || (aristas != grafica.aristas))
+            return false;
+        for(Vertice v : vertices) {
+            v.color = Color.ROJO;
+            if(!grafica.contiene(v.elemento))
+                return false;
+        }
+        for(Vertice v : vertices) {
+            for(Vecino y : v.vecinos){
+                if(y.getColor() == Color.ROJO)
+                   if(!grafica.sonVecinos(y.get(),v.elemento))
+                        return false;
+            }
+            v.color = Color.NEGRO;
+        }
+        return true;
     }
 
     /**
@@ -394,6 +624,38 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public Lista<VerticeGrafica<T>> trayectoriaMinima(T origen, T destino) {
         // Aquí va su código.
+        if(!contiene(origen) || !contiene(destino))
+            throw new NoSuchElementException();
+        Lista<VerticeGrafica<T>> lista = new Lista<VerticeGrafica<T>>();
+        Cola<Vertice> cola = new Cola<Vertice>();
+        Vertice x = busca(origen);
+        Vertice y = busca(destino);
+        if(origen.equals(destino)) {
+            lista.agrega(x);
+            return lista;
+        }
+        for(Vertice v : vertices)
+            v.distancia = -1;
+            x.distancia = 0;
+            cola.mete(x);
+            while(!cola.esVacia()) {
+                x = cola.saca();
+                for(Vecino vecino : x.vecinos)
+                    if(vecino.vecino.distancia == -1) {
+                    vecino.vecino.distancia = x.distancia +1;
+                    cola.mete(vecino.vecino);
+                    }
+            }
+        if(y.distancia == -1)
+            return lista;
+        lista.agrega(y);
+            while(!x.elemento.equals(origen))
+            for(Vecino vertice : x.vecinos)
+                if(x.distancia == vertice.vecino.distancia + 1) {
+                    lista.agrega(vertice.vecino);
+                    x = vertice.vecino;
+                }
+        return lista.reversa();
     }
 
     /**
@@ -409,5 +671,32 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public Lista<VerticeGrafica<T>> dijkstra(T origen, T destino) {
         // Aquí va su código.
+        if(!contiene(origen) || !contiene(destino))
+            throw new NoSuchElementException();
+        Lista<VerticeGrafica<T>> lista = new Lista<VerticeGrafica<T>>();
+        MonticuloMinimo<Vertice> monticuloMinimo = new MonticuloMinimo<Vertice>(vertices);
+        Vertice x = (Vertice) vertice(origen);
+        Vertice y = (Vertice) vertice(destino);
+        for(Vertice v : vertices)
+            v.distancia = Double.MAX_VALUE;
+        x.distancia = 0;
+        while(!monticuloMinimo.esVacia()) {
+            Vertice v = monticuloMinimo.elimina();
+            for(Vecino vertice : v.vecinos)
+                if(vertice.vecino.distancia > (v.distancia + vertice.peso)) {
+                    vertice.vecino.distancia = v.distancia + vertice.peso;
+                    monticuloMinimo.reordena(vertice.vecino);
+                }
+            }
+        if(y.distancia == Double.MAX_VALUE)
+            return lista;
+        lista.agrega(y);
+        while(!y.elemento.equals(origen))
+            for(Vecino vertice : y.vecinos)
+                if(y.distancia == vertice.vecino.distancia + vertice.peso) {
+                    lista.agrega(vertice.vecino);
+                    y = vertice.vecino;
+                }
+        return lista.reversa();
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Lista.java b/src/main/java/mx/unam/ciencias/edd/Lista.java
index f56592a..a35fd91 100644
--- a/src/main/java/mx/unam/ciencias/edd/Lista.java
+++ b/src/main/java/mx/unam/ciencias/edd/Lista.java
@@ -28,6 +28,7 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nodo con un elemento. */
         public Nodo(T elemento) {
+          this.elemento = elemento;
             // Aquí va su código.
         }
     }
@@ -41,36 +42,54 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador. */
         public Iterador() {
+          this.siguiente = cabeza;
+          this.anterior = null;
             // Aquí va su código.
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
+          return this.siguiente != null;
             // Aquí va su código.
         }
 
         /* Nos da el elemento siguiente. */
         @Override public T next() {
+          if (this.siguiente == null)
+           throw new NoSuchElementException();
+          this.anterior = this.siguiente;
+          this.siguiente = this.siguiente.siguiente;
+           return anterior.elemento;
             // Aquí va su código.
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
+          return this.anterior != null;
             // Aquí va su código.
         }
 
         /* Nos da el elemento anterior. */
         @Override public T previous() {
+          if (this.anterior == null)
+           throw new NoSuchElementException();
+          this.siguiente = this.anterior;
+          this.anterior = this.anterior.anterior;
+           return siguiente.elemento;
             // Aquí va su código.
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
+          siguiente = cabeza;
+          anterior = null;
             // Aquí va su código.
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
+          anterior = rabo;
+          siguiente = null;
             // Aquí va su código.
         }
     }
@@ -88,6 +107,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
+      return longitud;
         // Aquí va su código.
     }
 
@@ -97,6 +117,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return el número elementos en la lista.
      */
     @Override public int getElementos() {
+      return longitud;
         // Aquí va su código.
     }
 
@@ -106,6 +127,7 @@ public class Lista<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
+      return cabeza == null;
         // Aquí va su código.
     }
 
@@ -118,6 +140,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+       Nodo n = new Nodo (elemento);
+       longitud ++;
+       if (esVacia())
+          cabeza = rabo = n;
+        else {
+          rabo.siguiente = n;
+          n.anterior     = rabo;
+          rabo           = n;
+        }
         // Aquí va su código.
     }
 
@@ -129,6 +162,7 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
+      agrega(elemento);
         // Aquí va su código.
     }
 
@@ -140,6 +174,17 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaInicio(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+       Nodo n = new Nodo (elemento);
+       longitud ++;
+       if (esVacia())
+          cabeza = rabo = n;
+        else {
+          cabeza.anterior = n;
+          n.siguiente     = cabeza;
+          cabeza            = n;
+        }
         // Aquí va su código.
     }
 
@@ -159,6 +204,23 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void inserta(int i, T elemento) {
+      if (elemento == null)
+          throw new IllegalArgumentException();
+      else if (i <= 0)
+          agregaInicio(elemento);
+      else if (i >= longitud)
+          agregaFinal(elemento);
+      else {
+          Nodo n0 = cabeza;
+          Nodo n = new Nodo(elemento);
+          longitud++;
+          for (int c = 0; c < i; c++)
+              n0 = n0.siguiente;
+          n.anterior = n0.anterior;
+          n.siguiente = n0;
+          n.siguiente.anterior = n;
+          n.anterior.siguiente = n;
+      }
         // Aquí va su código.
     }
 
@@ -168,8 +230,26 @@ public class Lista<T> implements Coleccion<T> {
      * @param elemento el elemento a eliminar.
      */
     @Override public void elimina(T elemento) {
+      Nodo d = buscaNodo(cabeza, elemento);
+       if (d == null)
+           return;
+       else if (d.equals(cabeza))
+           eliminaPrimero();
+       else if (d.equals(rabo))
+           eliminaUltimo();
+       else {
+           d.anterior.siguiente = d.siguiente;
+           d.siguiente.anterior = d.anterior;
+           longitud--;
+       }
         // Aquí va su código.
     }
+    /*Método auxiliar para buscar un nodo en la lista. */
+    private Nodo buscaNodo(Nodo n, T elemento) {
+      if (n == null)
+         return null;
+      return n.elemento.equals(elemento)?n:buscaNodo(n.siguiente, elemento);
+    }
 
     /**
      * Elimina el primer elemento de la lista y lo regresa.
@@ -177,6 +257,17 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaPrimero() {
+      if (esVacia())
+          throw new NoSuchElementException();
+      T elemento = cabeza.elemento;
+      longitud--;
+      if (cabeza == rabo)
+          cabeza = rabo = null;
+       else {
+          cabeza = cabeza.siguiente;
+          cabeza.anterior = null;
+      }
+      return elemento;
         // Aquí va su código.
     }
 
@@ -186,6 +277,17 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T eliminaUltimo() {
+      if (esVacia())
+          throw new NoSuchElementException();
+      T elemento = rabo.elemento;
+      longitud--;
+      if (cabeza == rabo)
+          cabeza = rabo = null;
+       else {
+          rabo = rabo.anterior;
+          rabo.siguiente = null;
+      }
+      return elemento;
         // Aquí va su código.
     }
 
@@ -196,6 +298,7 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
+      return (buscaNodo(cabeza, elemento) != null)?true:false;
         // Aquí va su código.
     }
 
@@ -204,6 +307,13 @@ public class Lista<T> implements Coleccion<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
+      Lista<T> r = new Lista<T>();
+      Nodo n = cabeza;
+      while (n != null) {
+         r.agregaInicio(n.elemento);
+         n = n.siguiente;
+      }
+      return r;
         // Aquí va su código.
     }
 
@@ -213,6 +323,13 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copiad de la lista.
      */
     public Lista<T> copia() {
+      Lista<T> r = new Lista<T>();
+      Nodo n = cabeza;
+      while (n != null) {
+         r.agregaFinal(n.elemento);
+         n = n.siguiente;
+      }
+      return r;
         // Aquí va su código.
     }
 
@@ -220,6 +337,8 @@ public class Lista<T> implements Coleccion<T> {
      * Limpia la lista de elementos, dejándola vacía.
      */
     @Override public void limpia() {
+      cabeza = rabo = null;
+      longitud = 0;
         // Aquí va su código.
     }
 
@@ -229,6 +348,9 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getPrimero() {
+      if (esVacia())
+       throw new NoSuchElementException();
+      return cabeza.elemento;
         // Aquí va su código.
     }
 
@@ -238,6 +360,9 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getUltimo() {
+      if (esVacia())
+       throw new NoSuchElementException();
+      return rabo.elemento;
         // Aquí va su código.
     }
 
@@ -249,6 +374,12 @@ public class Lista<T> implements Coleccion<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
+      if (i < 0 || i >= longitud)
+       throw new ExcepcionIndiceInvalido();
+      Nodo n = cabeza;
+      while (i-- > 0)
+          n = n.siguiente;
+        return n.elemento;
         // Aquí va su código.
     }
 
@@ -259,6 +390,15 @@ public class Lista<T> implements Coleccion<T> {
      *         no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
+      int r = 0;
+      Nodo n = cabeza;
+      while (n != null) {
+        if(n.elemento.equals(elemento))
+        return r;
+        n = n.siguiente;
+        r++;
+      }
+      return -1;
         // Aquí va su código.
     }
 
@@ -267,6 +407,15 @@ public class Lista<T> implements Coleccion<T> {
      * @return una representación en cadena de la lista.
      */
     @Override public String toString() {
+      if (esVacia())
+      return  "[]";
+      String r  = "[" + cabeza.elemento.toString();
+      Nodo n = cabeza.siguiente;
+      while (n != null) {
+        r += ", " + n.elemento.toString();
+        n = n.siguiente;
+      }
+      return r + "]";
         // Aquí va su código.
     }
 
@@ -280,6 +429,19 @@ public class Lista<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
+        if (lista == null || longitud != lista.longitud)
+            return false;
+        Nodo n = cabeza;
+        Nodo m = lista.cabeza;
+        while (n != null) {
+           if (n.elemento.equals(m.elemento)) {
+            n = n.siguiente;
+            m = m.siguiente;
+          } else {
+            return false;
+          }
+        }
+        return true;
         // Aquí va su código.
     }
 
@@ -308,8 +470,47 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copia de la lista, pero ordenada.
      */
     public Lista<T> mergeSort(Comparator<T> comparador) {
+      if (this.esVacia() || this.longitud == 1)
+            return this;
+        Lista<T> li = new Lista<T>();
+        Lista<T> ld = new Lista<T>();
+        Nodo n = this.cabeza;
+        for (int i = 0; i < this.longitud; i++) {
+            if (i < this.longitud/2)
+                li.agregaFinal(n.elemento);
+            else
+                ld.agregaFinal(n.elemento);
+            n = n.siguiente;
+        }
+        return mezcla(comparador, li.mergeSort(comparador),
+                      ld.mergeSort(comparador));
         // Aquí va su código.
     }
+    /* Método auxiliar para mezclar los elementos de manera ordenada. */
+  private Lista<T> mezcla(Comparator<T> comparador, Lista<T> l1, Lista<T> l2)
+  {
+      Lista<T> r = new Lista<T>();
+      Nodo i = l1.cabeza;
+      Nodo j = l2.cabeza;
+      while (i != null && j != null) {
+          if (comparador.compare(i.elemento, j.elemento) <= 0) {
+              r.agregaFinal(i.elemento);
+              i = i.siguiente;
+          } else {
+              r.agregaFinal(j.elemento);
+              j = j.siguiente;
+          }
+      }
+      while (i != null) {
+          r.agregaFinal(i.elemento);
+          i = i.siguiente;
+      }
+      while (j != null) {
+          r.agregaFinal(j.elemento);
+          j = j.siguiente;
+      }
+      return r;
+  }
 
     /**
      * Regresa una copia de la lista recibida, pero ordenada. La lista recibida
@@ -333,6 +534,13 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
+      Nodo n = cabeza;
+      while (n != null) {
+        if (comparador.compare(n.elemento, elemento) == 0)
+           return true;
+           n = n.siguiente;
+      }
+      return false;
         // Aquí va su código.
     }
 
diff --git a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
index 8864077..1e7076b 100644
--- a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
@@ -22,6 +22,7 @@ public abstract class MeteSaca<T> {
          * @param elemento el elemento del nodo.
          */
         public Nodo(T elemento) {
+          this.elemento = elemento;
             // Aquí va su código.
         }
     }
@@ -43,6 +44,13 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T saca() {
+      if (cabeza == null)
+            throw new NoSuchElementException();
+        T r = cabeza.elemento;
+        cabeza = cabeza.siguiente;
+        if (cabeza == null)
+            rabo = null;
+        return r;
         // Aquí va su código.
     }
 
@@ -53,6 +61,9 @@ public abstract class MeteSaca<T> {
      * @throws NoSuchElementException si la estructura está vacía.
      */
     public T mira() {
+      if (cabeza == null)
+            throw new NoSuchElementException();
+        return cabeza.elemento;
         // Aquí va su código.
     }
 
@@ -62,6 +73,7 @@ public abstract class MeteSaca<T> {
      *         <code>false</code> en otro caso.
      */
     public boolean esVacia() {
+      return cabeza == null;
         // Aquí va su código.
     }
 
@@ -76,6 +88,18 @@ public abstract class MeteSaca<T> {
         if (object == null || getClass() != object.getClass())
             return false;
         @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
+        Nodo n1 = cabeza;
+        Nodo n2 = m.cabeza;
+        while (n1 != null) {
+            if (n2 == null)
+                return false;
+            else if (n1.elemento.equals(n2.elemento)) {
+                n1 = n1.siguiente;
+                n2 = n2.siguiente;
+            } else
+                return false;
+        }
+        return true;
         // Aquí va su código.
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java b/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
index 125ce61..64b8c04 100644
--- a/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
+++ b/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
@@ -38,6 +38,14 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     public MonticuloArreglo(Iterable<T> iterable, int n) {
         // Aquí va su código.
+        int indiceAux = 0;
+        arreglo = nuevoArreglo(n);
+        for (T elemento : iterable) {
+            arreglo[indiceAux] = elemento;
+            elemento.setIndice(indiceAux);
+            indiceAux+=1;
+        }
+        elementos = n;
     }
 
     /**
@@ -47,6 +55,28 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public T elimina() {
         // Aquí va su código.
+        if(elementos == 0)
+           throw new IllegalStateException();
+        T elemento = null;
+        for (int i = 0; i < arreglo.length; i++){
+            if(arreglo[i] != null){
+             elemento = arreglo[i];
+             break;
+            }
+        }
+        int ielemento = elemento.getIndice();
+        for(int j = 1; j < arreglo.length; j++){
+            if (arreglo[j] != null){
+                if (elemento.compareTo(arreglo[j]) > 0){
+                  elemento = arreglo[j];
+                  ielemento = arreglo[j].getIndice();
+                }
+            }
+        }
+        arreglo[ielemento].setIndice(-1);
+        arreglo[ielemento] = null;
+        elementos--;
+        return elemento;
     }
 
     /**
@@ -58,6 +88,9 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public T get(int i) {
         // Aquí va su código.
+        if(i<0 || i>=elementos)
+            throw new NoSuchElementException();
+        return arreglo[i];
     }
 
     /**
@@ -67,6 +100,7 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public boolean esVacia() {
         // Aquí va su código.
+        return (elementos == 0);
     }
 
     /**
@@ -75,5 +109,6 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public int getElementos() {
         // Aquí va su código.
+        return this.elementos;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java b/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
index 1afb359..a237756 100644
--- a/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
+++ b/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
@@ -18,11 +18,15 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
             // Aquí va su código.
+            return (indice < arbol.length && arbol[indice] != null);
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
             // Aquí va su código.
+            if (indice >= arbol.length)
+                throw new NoSuchElementException();
+            return arbol[indice++];
         }
     }
 
@@ -38,21 +42,27 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
         /* Crea un nuevo comparable indexable. */
         public Adaptador(T elemento) {
             // Aquí va su código.
+            this.elemento = elemento;
+            this.indice = -1;
         }
 
         /* Regresa el índice. */
         @Override public int getIndice() {
             // Aquí va su código.
+            return this.indice;
         }
 
         /* Define el índice. */
         @Override public void setIndice(int indice) {
             // Aquí va su código.
+            this.indice = indice;
         }
 
         /* Compara un adaptador con otro. */
         @Override public int compareTo(Adaptador<T> adaptador) {
             // Aquí va su código.
+            return this.elemento.compareTo(adaptador.elemento);
+
         }
     }
 
@@ -100,6 +110,17 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     public MonticuloMinimo(Iterable<T> iterable, int n) {
         // Aquí va su código.
+        this.arbol = nuevoArreglo(n);
+        int indiceAux = 0;
+        elementos = n;
+        for(T elemento : iterable){
+           arbol[indiceAux] = elemento;
+           elemento.setIndice(indiceAux);
+           indiceAux+=1;
+        }
+        int indexMonticulo = (n-1)/2 ;
+        for(int i = indexMonticulo; i >= 0; i--)
+           heapifyDown(arbol[i]);
     }
 
     /**
@@ -108,6 +129,71 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        if (elementos == arbol.length){
+           T[] aux = nuevoArreglo(elementos*2);
+           for(int i = 0; i < elementos; i++)
+              aux[i] = arbol[i];
+           arbol = aux;
+        }
+        arbol[elementos] = elemento;
+        elemento.setIndice(elementos);
+        elementos++;
+        heapifyUp(elemento);
+    }
+
+    /**
+     * Método auxiliar para intercambiar dos elementos.
+     * @param i uno de los elementos que va a participar en el intercambio.
+     * @param j uno de los elementos que va a participar en el intercambio.
+     */
+    private void intercambia(T i, T j){
+        int aux = j.getIndice();
+        arbol[i.getIndice()] = j;
+        arbol[j.getIndice()] = i;
+        j.setIndice(i.getIndice());
+        i.setIndice(aux);
+    }
+
+    private boolean indiceValido(int i){
+        return !(i < 0 ||  i >= elementos);
+    }
+
+    /**
+     * Método auxiliar que simula el algoritmo heapify-down.
+     * @param elemento que vamos a acomodar hacia abajo.
+     */
+    private void heapifyDown(T elemento){
+        if (elemento == null)
+           return;
+        int izquierdo = elemento.getIndice() * 2 + 1;
+        int derecho = elemento.getIndice() * 2 + 2;
+        if(!indiceValido(izquierdo) && !indiceValido(derecho))
+           return;
+        int minimo = derecho;
+        if(indiceValido(izquierdo)){
+           if(indiceValido(derecho)) {
+              if(arbol[izquierdo].compareTo(arbol[derecho]) < 0)
+              minimo = izquierdo;
+           }else
+             minimo = izquierdo;
+        }
+        if(elemento.compareTo(arbol[minimo]) > 0){
+           intercambia(elemento, arbol[minimo]);
+           heapifyDown(elemento);
+        }
+    }
+
+    /**
+     * Método auxiliar que simula el algoritmo heapify-up.
+     * @param elemento que vamos a acomodar hacia arriba.
+     */
+    private void heapifyUp(T elemento){
+        int padre = elemento.getIndice()-1;
+        padre = padre == -1 ? -1 : padre / 2;
+        if(!indiceValido(padre) || arbol[padre].compareTo(elemento) < 0)
+           return;
+        intercambia(arbol[padre], elemento);
+        heapifyUp(elemento);
     }
 
     /**
@@ -117,6 +203,16 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public T elimina() {
         // Aquí va su código.
+        if(esVacia())
+            throw new IllegalStateException();
+        T raiz = arbol[0];
+        T ultimoElemento = arbol[elementos-1];
+        intercambia(raiz,ultimoElemento);
+        elementos-=1;
+        arbol[elementos].setIndice(-1);
+        arbol[elementos]= null;
+        heapifyDown(arbol[0]);
+        return raiz;
     }
 
     /**
@@ -125,6 +221,15 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        int indiceAux = elemento.getIndice();
+        if(!indiceValido(indiceAux))
+          return;
+        intercambia(arbol[indiceAux], arbol[elementos-1]);
+        elementos-=1;
+        arbol[elementos] = null;
+        elemento.setIndice(-1);
+        reordena(arbol[indiceAux]);
+
     }
 
     /**
@@ -135,6 +240,8 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public boolean contiene(T elemento) {
         // Aquí va su código.
+        int indiceAux = elemento.getIndice();
+        return(!indiceValido(indiceAux)) ? false : (arbol[indiceAux].compareTo(elemento) == 0);
     }
 
     /**
@@ -144,6 +251,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public boolean esVacia() {
         // Aquí va su código.
+        return (elementos == 0);
     }
 
     /**
@@ -151,6 +259,9 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void limpia() {
         // Aquí va su código.
+        for(int i = 0; i < elementos; i++)
+          arbol[i] = null;
+        elementos = 0;
     }
 
    /**
@@ -159,6 +270,14 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void reordena(T elemento) {
         // Aquí va su código.
+        if(elemento == null)
+          return;
+        int padre = elemento.getIndice() - 1;
+        padre = padre == -1 ? -1 : padre/2;
+        if(!indiceValido(padre) || arbol[padre].compareTo(elemento) <= 0)
+          heapifyDown(elemento);
+        else
+          heapifyUp(elemento);
     }
 
     /**
@@ -167,6 +286,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public int getElementos() {
         // Aquí va su código.
+        return this.elementos;
     }
 
     /**
@@ -178,6 +298,9 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public T get(int i) {
         // Aquí va su código.
+        if (i<0 || i>= elementos)
+            throw new NoSuchElementException();
+        return arbol[i];
     }
 
     /**
@@ -186,6 +309,10 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public String toString() {
         // Aquí va su código.
+        String s = "";
+        for(int i = 0; i < arbol.length; i++)
+           s += arbol[i] + ", ";
+        return s;
     }
 
     /**
@@ -200,6 +327,12 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
         @SuppressWarnings("unchecked") MonticuloMinimo<T> monticulo =
             (MonticuloMinimo<T>)objeto;
         // Aquí va su código.
+        if(monticulo.getElementos() != getElementos())
+            return false;
+        for(int i = 0; i < getElementos(); i++)
+           if(!arbol[i].equals(monticulo.get(i)))
+            return false;
+        return true;
     }
 
     /**
@@ -220,5 +353,13 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
     public static <T extends Comparable<T>>
     Lista<T> heapSort(Coleccion<T> coleccion) {
         // Aquí va su código.
+        Lista<Adaptador<T>> lista = new Lista<Adaptador<T>>();
+        for(T elementoColeccion : coleccion)
+           lista.agrega(new Adaptador<T>(elementoColeccion));
+        Lista<T> lista2 = new Lista<T>();
+        MonticuloMinimo<Adaptador<T>> monticulo = new MonticuloMinimo<Adaptador<T>>(lista);
+        while(!monticulo.esVacia())
+           lista2.agrega(monticulo.elimina().elemento);
+        return lista2;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Pila.java b/src/main/java/mx/unam/ciencias/edd/Pila.java
index fc800e7..9fda793 100644
--- a/src/main/java/mx/unam/ciencias/edd/Pila.java
+++ b/src/main/java/mx/unam/ciencias/edd/Pila.java
@@ -10,6 +10,15 @@ public class Pila<T> extends MeteSaca<T> {
      * @return una representación en cadena de la pila.
      */
     @Override public String toString() {
+      String r = "";
+      if (cabeza == null)
+          return r;
+      Nodo n = cabeza;
+      while (n != null) {
+          r += n.elemento.toString() + "\n";
+          n = n.siguiente;
+      }
+      return r;
         // Aquí va su código.
     }
 
@@ -20,6 +29,15 @@ public class Pila<T> extends MeteSaca<T> {
      *         <code>null</code>.
      */
     @Override public void mete(T elemento) {
+      if (elemento == null)
+       throw new IllegalArgumentException();
+       Nodo n = new Nodo (elemento);
+     if (cabeza == null)
+         cabeza = rabo = n;
+     else {
+       n.siguiente = cabeza;
+       cabeza = n;
+     }
         // Aquí va su código.
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java b/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
index 15ba2bf..4f099e5 100644
--- a/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
+++ b/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
@@ -20,6 +20,9 @@ public class ValorIndexable<T>
      */
     public ValorIndexable(T elemento, double valor) {
         // Aquí va su código.
+        this.elemento = elemento;
+        this.valor = valor;
+        this.indice = -1;
     }
 
     /**
@@ -28,6 +31,7 @@ public class ValorIndexable<T>
      */
     public T getElemento() {
         // Aquí va su código.
+        return this.elemento;
     }
 
     /**
@@ -39,6 +43,11 @@ public class ValorIndexable<T>
      */
     @Override public int compareTo(ValorIndexable<T> valorIndexable) {
         // Aquí va su código.
+        if (this.valor < valorIndexable.getValor())
+            return -1;
+        if (this.valor > valorIndexable.getValor())
+            return 1;
+        return 0;
     }
 
     /**
@@ -47,6 +56,7 @@ public class ValorIndexable<T>
      */
     @Override public void setIndice(int indice) {
         // Aquí va su código.
+        this.indice = indice;
     }
 
     /**
@@ -55,6 +65,7 @@ public class ValorIndexable<T>
      */
     @Override public int getIndice() {
         // Aquí va su código.
+        return this.indice;
     }
 
     /**
@@ -63,6 +74,7 @@ public class ValorIndexable<T>
      */
     public void setValor(double valor) {
         // Aquí va su código.
+        this.valor = valor;
     }
 
     /**
@@ -71,6 +83,7 @@ public class ValorIndexable<T>
      */
     public double getValor() {
         // Aquí va su código.
+        return this.valor;
     }
 
     /**
@@ -85,6 +98,9 @@ public class ValorIndexable<T>
         @SuppressWarnings("unchecked") ValorIndexable<T> valorIndexable =
             (ValorIndexable<T>)objeto;
         // Aquí va su código.
+        if(valor == valorIndexable.getValor())
+          return true;
+        return false;
     }
 
     /**
@@ -93,5 +109,6 @@ public class ValorIndexable<T>
      */
     @Override public String toString() {
         // Aquí va su código.
+        return elemento + String.format(":%2.9f", valor);
     }
 }
